---
import "../styles/global.css";
import Icon from "../components/Icon.astro";
import InProgressCard from "../components/InProgressCard.astro";
import { getEntry } from "astro:content";

// Fetch home entry for site-wide configuration.
// Content-driven approach: site metadata, navigation, and footer content
// now live in src/content/home/index.md instead of being hardcoded.
const homeEntry = await getEntry("home", "index");
const {
  socialLinks,
  email,
  footerText,
  // Site metadata previously hardcoded in this file
  siteName,
  ogImage,
  // Navigation links previously hardcoded as const arrays
  navLinks,
} = homeEntry?.data || {};

// Derive navigation arrays from content-driven navLinks.
// Fallback to sensible defaults if navLinks is not defined in markdown.
// Home (href: "/") is excluded from visibleNavLinks because it's accessed via logo.
const visibleNavLinks =
  navLinks?.filter((link) => link.visible !== false && link.href !== "/") ||
  [
    { href: "/about", label: "About" },
    { href: "/contact", label: "Contact" },
    { href: "/blog", label: "Writing" },
    { href: "/now", label: "Now" },
    { href: "/uses", label: "Uses" },
  ];

const allNavLinks =
  navLinks || [
    { href: "/", label: "Home" },
    { href: "/about", label: "About" },
    { href: "/contact", label: "Contact" },
    { href: "/blog", label: "Writing" },
    { href: "/now", label: "Now" },
    { href: "/uses", label: "Uses" },
    { href: "/photography", label: "Photography" },
    { href: "/notes", label: "Notes" },
    { href: "/talks", label: "Talks" },
  ];

// Helper to map social labels to icon names
const getIconName = (label: string) => {
  const lower = label.toLowerCase();
  if (lower.includes("github")) return "github";
  if (lower.includes("twitter") || lower.includes("x")) return "twitter";
  if (lower.includes("linkedin")) return "linkedin";
  if (lower.includes("mastodon")) return "mastodon";
  if (lower.includes("telegram")) return "telegram";
  return "link"; // Fallback icon
};

interface Props {
  title: string;
  description?: string;
  hideNavInitially?: boolean;
  /** Show in-progress card instead of content */
  displayInProgress?: boolean;
  /**
   * Page-specific OG image for social sharing.
   * Falls back to home entry's ogImage if not provided.
   * Can be set from entry's cover-image frontmatter.
   */
  ogImage?: string;
}

const {
  title,
  description = "Personal website",
  hideNavInitially = false,
  displayInProgress = false,
  ogImage: pageOgImage,
} = Astro.props;

const currentPath = Astro.url.pathname;

// Content-driven site metadata with fallback defaults.
// Page-specific ogImage takes priority over home entry default.
// Falls back to home entry ogImage, then hardcoded default.
const resolvedSiteName = siteName || "kayg's public repertoire";
const resolvedOgImage = pageOgImage || ogImage || "https://kayg.org/images/og-image.webp";

import { ClientRouter } from "astro:transitions";
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta
      name="theme-color"
      content="#faf8fc"
      media="(prefers-color-scheme: light)"
    />
    <meta
      name="theme-color"
      content="#0d0910"
      media="(prefers-color-scheme: dark)"
    />
    <meta name="description" content={description} />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>

    <!-- Open Graph meta tags for social sharing -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={resolvedOgImage} />
    <meta property="og:url" content={Astro.url.href} />
    <meta property="og:site_name" content={resolvedSiteName} />

    <!-- Twitter Card meta tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={resolvedOgImage} />

    <!-- Canonical URL to prevent duplicate content issues -->
    <link rel="canonical" href={Astro.url.href} />

    <!-- JSON-LD Structured Data for SEO -->
    <script
      type="application/ld+json"
      set:html={JSON.stringify({
        "@context": "https://schema.org",
        "@graph": [
          {
            "@type": "Person",
            "@id": "https://kayg.org/#person",
            name: resolvedSiteName,
            url: "https://kayg.org",
            image: resolvedOgImage,
          },
          {
            "@type": "Website",
            "@id": "https://kayg.org/#website",
            name: resolvedSiteName,
            url: "https://kayg.org",
            description: description,
            author: { "@id": "https://kayg.org/#person" },
            publisher: { "@id": "https://kayg.org/#person" },
          },
          {
            "@type": "BreadcrumbList",
            itemListElement: [
              {
                "@type": "ListItem",
                position: 1,
                name: "Home",
                item: "https://kayg.org",
              },
              ...(currentPath !== "/"
                ? [
                    {
                      "@type": "ListItem",
                      position: 2,
                      name: title,
                      item: Astro.url.href,
                    },
                  ]
                : []),
            ],
          },
        ],
      })}
    />

    <!-- Preconnect to external image CDN for faster loading -->
    <link rel="preconnect" href="https://images.unsplash.com" />
    <link rel="dns-prefetch" href="https://images.unsplash.com" />

    <ClientRouter />
    <!-- Fonts: self-hosted via fontsource with font-display: swap -->
    <!-- Theme detection: respects system preference, allows override -->
    <script is:inline>
      (function () {
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme) {
          document.documentElement.setAttribute("data-theme", savedTheme);
        } else {
          // No saved preference: use system preference
          const prefersDark = window.matchMedia(
            "(prefers-color-scheme: dark)",
          ).matches;
          document.documentElement.setAttribute(
            "data-theme",
            prefersDark ? "dark" : "light",
          );
        }

        // Set initial theme color for both meta tags
        const currentTheme =
          document.documentElement.getAttribute("data-theme");
        const themeColorLight = document.querySelector(
          'meta[name="theme-color"][media*="light"]',
        );
        const themeColorDark = document.querySelector(
          'meta[name="theme-color"][media*="dark"]',
        );
        const bgColor = currentTheme === "dark" ? "#0d0910" : "#faf8fc";
        if (themeColorLight) themeColorLight.setAttribute("content", bgColor);
        if (themeColorDark) themeColorDark.setAttribute("content", bgColor);
      })();
    </script>
  </head>
  <body class="min-h-screen text-base-content">
    <!-- Skip to main content link for keyboard/screen reader users -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <!-- Animated Film Grain Background -->
    <div class="animated-gradient-bg" aria-hidden="true" transition:persist>
      <!-- Soft color flares (like light leaks) -->
      <div class="film-flare"></div>
      <!-- Subtle color tint -->
      <div class="film-tint"></div>
      <!-- Vignette darkening at edges -->
      <div class="film-vignette"></div>
    </div>

    <!-- Global Image Zoom Overlay with Gallery Navigation -->
    <div id="zoom-overlay" class="zoom-overlay" aria-hidden="true">
      <button id="zoom-close" class="zoom-close" aria-label="Close">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <img id="zoomed-image" class="zoomed-image" src="" alt="" />
      <!-- Caption/description display for gallery images -->
      <div id="zoom-caption" class="zoom-caption">
        <p id="zoom-caption-title" class="zoom-caption-title"></p>
        <p id="zoom-caption-description" class="zoom-caption-description"></p>
        <p id="zoom-caption-meta" class="zoom-caption-meta"></p>
      </div>
      <!-- Navigation controls in flex container for proper alignment -->
      <div class="zoom-controls">
        <button
          id="zoom-prev"
          class="zoom-nav zoom-prev"
          aria-label="Previous image"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="28"
            height="28"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>
        <div id="zoom-counter" class="zoom-counter"></div>
        <button
          id="zoom-next"
          class="zoom-nav zoom-next"
          aria-label="Next image"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="28"
            height="28"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </button>
      </div>
    </div>

    <!-- Floating Pill Navigation -->
    <nav
      id="nav-container"
      class:list={[
        "fixed top-0 left-0 right-0 z-50 p-4 nav-container",
        hideNavInitially ? "nav-hidden" : "nav-visible",
      ]}
    >
      <div class="max-w-4xl mx-auto">
        <!-- Desktop: Three separate pills -->
        <div class="hidden md:flex items-center justify-center gap-3">
          <!-- Left pill: Logo -->
          <a href="/" class="glass-pill nav-logo px-3 py-2 transition-all">
            <span class="nav-logo-text"
              >@kayg<span class="nav-logo-expand">dotorg</span></span
            >
          </a>

          <!-- Center pill: Nav links -->
          <div class="glass-pill px-2 py-1">
            <ul class="nav-link-container flex items-center gap-1 text-sm">
              {
                visibleNavLinks.map((link) => (
                  <li>
                    <a
                      href={link.href}
                      class:list={[
                        "nav-link block px-3 py-1.5 rounded-full transition-all",
                        currentPath === link.href
                          ? "bg-base-content/10 text-accent"
                          : "text-base-content/70 hover:text-base-content hover:bg-base-content/5",
                      ]}
                    >
                      {link.label}
                    </a>
                  </li>
                ))
              }
            </ul>
          </div>

          <!-- Right pill: Search + Theme toggle + Menu toggle -->
          <div class="glass-pill flex items-center gap-1 p-1">
            <button
              id="search-toggle-desktop"
              class="search-pill flex items-center hover:bg-base-content/10 transition-all rounded-full p-2 group"
              aria-label="Search"
            >
              <Icon
                name="search"
                class="w-5 h-5 text-base-content/70 group-hover:text-base-content"
              />
              <span
                class="search-expand-label text-sm font-medium text-base-content/70"
              >
                Search <span id="search-shortcut-label" class="opacity-50 ml-1"
                  >CMD + K</span
                >
              </span>
            </button>
            <button
              id="theme-toggle-desktop"
              class="p-2 rounded-full hover:bg-base-content/10 transition-colors cursor-pointer flex items-center"
              aria-label="Toggle dark mode"
            >
              <Icon name="sun" id="sun-icon-desktop" class="sun-icon w-5 h-5" />
              <Icon
                name="moon"
                id="moon-icon-desktop"
                class="moon-icon w-5 h-5"
              />
              <span
                class="theme-expand-label text-sm font-medium text-base-content/70"
              >
                Theme <span id="theme-shortcut-label" class="opacity-50 ml-1"
                  >CMD + D</span
                >
              </span>
            </button>
            <button
              id="menu-toggle-desktop"
              class="p-2 rounded-full hover:bg-base-content/10 transition-colors cursor-pointer flex items-center"
              aria-label="Open menu"
            >
              <Icon
                name="hamburger"
                id="hamburger-icon-desktop"
                class="w-5 h-5"
              />
              <Icon
                name="close"
                id="close-icon-desktop"
                class="w-5 h-5 hidden"
              />
              <span
                class="menu-expand-label text-sm font-medium text-base-content/70"
              >
                Menu <span id="menu-shortcut-label" class="opacity-50 ml-1"
                  >CMD + /</span
                >
              </span>
            </button>
          </div>
        </div>
      </div>

      <!-- Mobile: Logo left, controls right -->
      <div class="flex md:hidden items-center justify-between">
        <!-- Left pill: Logo -->
        <a
          href="/"
          class="glass-pill nav-logo nav-logo-mobile px-3 py-2 transition-all"
        >
          <span class="nav-logo-text">@kaygdotorg</span>
        </a>

        <!-- Right pill: Search + Theme toggle + Hamburger -->
        <div class="glass-pill flex items-center gap-1 p-1">
          <button
            id="search-toggle-mobile"
            class="p-2 rounded-full hover:bg-base-content/10 transition-colors cursor-pointer"
            aria-label="Search"
          >
            <Icon name="search" class="w-5 h-5" strokeWidth={2} />
          </button>
          <button
            id="theme-toggle-mobile"
            class="p-2 rounded-full hover:bg-base-content/10 transition-colors cursor-pointer"
            aria-label="Toggle dark mode"
          >
            <Icon name="sun" class="sun-icon w-5 h-5" strokeWidth={2} />
            <Icon name="moon" class="moon-icon w-5 h-5" strokeWidth={2} />
          </button>
          <button
            id="mobile-menu-toggle"
            class="p-2 rounded-full hover:bg-base-content/10 transition-colors cursor-pointer"
            aria-label="Open menu"
          >
            <Icon
              name="hamburger"
              id="hamburger-icon"
              class="w-5 h-5"
              strokeWidth={2}
            />
            <Icon
              name="close"
              id="close-icon"
              class="w-5 h-5 hidden"
              strokeWidth={2}
            />
          </button>
        </div>
      </div>
    </nav>

    <!-- Progressive Blur Overlay (variable blur below navbar) -->
    <div
      id="navbar-blur"
      class:list={["navbar-blur-overlay", hideNavInitially && "blur-hidden"]}
      aria-hidden="true"
    >
    </div>

    <!-- Mobile Menu Overlay (centered) -->
    <div id="mobile-menu" class="mobile-menu-container fixed inset-0 z-40">
      <!-- Backdrop - dims and blurs the page -->
      <div
        id="mobile-menu-backdrop"
        class="mobile-menu-backdrop absolute inset-0"
      >
      </div>

      <!-- Centered menu panel with grainy card -->
      <div
        id="mobile-menu-inner"
        class="absolute inset-0 flex items-center justify-center p-6"
      >
        <div class="mobile-menu-card frosted-card w-full max-w-sm p-6">
          <ul class="flex flex-col gap-2">
            {
              allNavLinks.map((link) => (
                <li>
                  <a
                    href={link.href}
                    class:list={[
                      "block px-4 py-3 rounded-2xl text-lg text-center transition-all",
                      currentPath === link.href
                        ? "bg-base-content/10 text-accent font-medium"
                        : "text-base-content/80 hover:text-base-content hover:bg-base-content/5",
                    ]}
                  >
                    {link.label}
                  </a>
                </li>
              ))
            }
            <li class="mt-4 flex justify-center">
              <button
                id="menu-search-toggle"
                class="p-4 rounded-2xl text-base-content/60 hover:text-base-content hover:bg-base-content/10 transition-all cursor-pointer group"
                aria-label="Search"
              >
                <Icon
                  name="search"
                  class="w-6 h-6 group-hover:scale-110 transition-transform"
                  strokeWidth={2}
                />
              </button>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Search Modal -->
    <div id="search-modal" class="search-modal-container fixed inset-0 z-[60]">
      <div id="search-backdrop" class="search-backdrop absolute inset-0"></div>
      <div
        id="search-modal-inner"
        class="absolute inset-0 flex items-start justify-center pt-20 md:pt-32 p-4"
      >
        <div class="search-modal-card frosted-card w-full max-w-2xl">
          <div id="search-container"></div>
        </div>
      </div>
    </div>

    <!-- Main content -->
    <main
      id="main-content"
      class={`relative z-10 ${hideNavInitially ? "" : "pt-24"}`}
    >
      {displayInProgress ? <InProgressCard title={title} /> : <slot />}
    </main>

    <style>
      /* When using page cards, remove footer margin */
      main:has(.page-cards-container) + footer {
        display: none;
      }

      /* Hide navbar when mobile menu or search is active */
      :global(body.mobile-menu-active) .nav-container,
      :global(body.search-active) .nav-container {
        opacity: 0 !important;
        pointer-events: none !important;
        transform: translateY(-20px) !important;
        transition:
          opacity 0.3s ease,
          transform 0.3s ease !important;
      }

      .nav-container {
        transition:
          opacity 0.3s ease,
          transform 0.3s ease;
      }
    </style>

    <!-- Footer -->
    <footer class="relative z-10 border-t border-base-content/10 mt-24">
      <div class="max-w-4xl mx-auto px-6 py-12">
        <div
          class="flex flex-col md:flex-row justify-between items-start md:items-center gap-6"
        >
          <p class="text-sm text-base-content/60">
            &copy; {new Date().getFullYear()} · {
              footerText || "Built with curiosity"
            }
          </p>
          <div class="flex items-center gap-4">
            {
              socialLinks?.map((link) => (
                <a
                  href={link.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  class="text-base-content/60 hover:text-base-content transition-colors"
                  aria-label={link.label}
                >
                  <Icon name={getIconName(link.label)} class="w-5 h-5" />
                </a>
              ))
            }
            {
              email && (
                <a
                  href={`mailto:${email}`}
                  class="text-base-content/60 hover:text-base-content transition-colors"
                  aria-label="Email"
                >
                  <Icon name="email" class="w-5 h-5" />
                </a>
              )
            }
          </div>
        </div>
      </div>
    </footer>

    <!-- Scroll Progress Button (outside stacking contexts, hidden on homepage) -->
    <button
      id="scroll-progress-btn"
      class:list={[
        "scroll-progress-btn",
        currentPath === "/" ? "hidden-permanently" : "hidden",
      ]}
      aria-label="Scroll to top or bottom"
    >
      <svg class="scroll-progress-ring" viewBox="0 0 36 36">
        <circle
          class="scroll-progress-bg"
          cx="18"
          cy="18"
          r="16"
          fill="none"
          stroke-width="2"></circle>
        <circle
          class="scroll-progress-fill"
          cx="18"
          cy="18"
          r="16"
          fill="none"
          stroke-width="2"></circle>
      </svg>
      <Icon
        name="arrow-down"
        class="scroll-progress-icon scroll-down"
        strokeWidth={2}
      />
      <Icon
        name="arrow-up"
        class="scroll-progress-icon scroll-up hidden"
        strokeWidth={2}
      />
    </button>

    <!-- Scripts -->
    <script>
      // =========================================================================
      // THEME TOGGLE UTILITY
      // =========================================================================
      //
      // Shared function used by both click handlers and keyboard shortcuts.
      // Consolidates all theme switching logic in one place.
      //
      // WHAT IT DOES:
      // 1. Toggles data-theme attribute between 'dark' and 'light'
      // 2. Persists preference to localStorage
      // 3. Updates theme-color meta tags (for Safari address bar color)
      // 4. Adds/removes theme-transitioning class for smooth CSS transitions
      //
      // CALLED BY:
      // - Click handler on theme toggle buttons (desktop + mobile)
      // - Keyboard shortcut: CMD/CTRL + D
      //
      // =========================================================================
      function toggleTheme() {
        const html = document.documentElement;
        const currentTheme = html.getAttribute("data-theme");
        const newTheme = currentTheme === "dark" ? "light" : "dark";

        // Add transitioning class for CSS animations
        html.classList.add("theme-transitioning");

        // Update theme attribute and persist to localStorage
        html.setAttribute("data-theme", newTheme);
        localStorage.setItem("theme", newTheme);

        // Update theme-color meta tags for Safari address bar
        // Both light and dark media queries get the same color since
        // we're overriding the preferred color scheme with user choice
        const bgColor = newTheme === "dark" ? "#0d0910" : "#faf8fc";
        const themeColorLight = document.querySelector(
          'meta[name="theme-color"][media*="light"]',
        );
        const themeColorDark = document.querySelector(
          'meta[name="theme-color"][media*="dark"]',
        );
        if (themeColorLight) themeColorLight.setAttribute("content", bgColor);
        if (themeColorDark) themeColorDark.setAttribute("content", bgColor);

        // Remove transitioning class after animation completes (300ms)
        setTimeout(() => {
          html.classList.remove("theme-transitioning");
        }, 300);
      }

      // Initialize theme toggle on every page load (needed for View Transitions)
      function initThemeToggle() {
        const themeToggles = [
          document.getElementById("theme-toggle-desktop"),
          document.getElementById("theme-toggle-mobile"),
        ];

        themeToggles.forEach((toggle) => {
          if (!toggle) return;
          // Remove old listeners by cloning the element
          const newToggle = toggle.cloneNode(true);
          if (newToggle && toggle.parentNode) {
            toggle.parentNode.replaceChild(newToggle, toggle);
            newToggle.addEventListener("click", toggleTheme);
          }
        });
      }

      // Initialize on first load
      initThemeToggle();

      /**
       * Restore theme from localStorage after View Transitions navigation.
       * View Transitions may reset the theme attribute, so we reapply it.
       */
      function restoreTheme() {
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme) {
          document.documentElement.setAttribute("data-theme", savedTheme);
        } else {
          const prefersDark = window.matchMedia(
            "(prefers-color-scheme: dark)",
          ).matches;
          document.documentElement.setAttribute(
            "data-theme",
            prefersDark ? "dark" : "light",
          );
        }

        // Restore theme-color meta for Safari
        const currentTheme =
          document.documentElement.getAttribute("data-theme");
        const themeColorMeta = document.querySelector(
          'meta[name="theme-color"]',
        );
        if (themeColorMeta) {
          themeColorMeta.setAttribute(
            "content",
            currentTheme === "dark" ? "#0d0910" : "#faf8fc",
          );
        }
      }

      // Pause animations when tab is hidden (performance)
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          document.body.classList.add("reduce-motion");
        } else {
          document.body.classList.remove("reduce-motion");
        }
      });

      // Global menu toggle (mobile/desktop) - wrapped for View Transitions
      function initGlobalMenu() {
        const mobileMenu = document.getElementById("mobile-menu");
        const mobileMenuBackdrop = document.getElementById(
          "mobile-menu-backdrop",
        );
        const mobileMenuInner = document.getElementById("mobile-menu-inner");
        const hamburgerIcons = [
          document.getElementById("hamburger-icon"),
          document.getElementById("hamburger-icon-desktop"),
        ];
        const closeIcons = [
          document.getElementById("close-icon"),
          document.getElementById("close-icon-desktop"),
        ];

        function openMenu() {
          mobileMenu?.classList.add("menu-open");
          document.body.classList.add("mobile-menu-active");
          hamburgerIcons.forEach((icon) => icon?.classList.add("hidden"));
          closeIcons.forEach((icon) => icon?.classList.remove("hidden"));
          document.body.style.overflow = "hidden";
        }

        function closeMenu() {
          mobileMenu?.classList.remove("menu-open");
          // Remove body class after all menu animations finish (0.4s total)
          setTimeout(() => {
            document.body.classList.remove("mobile-menu-active");
          }, 400);
          hamburgerIcons.forEach((icon) => icon?.classList.remove("hidden"));
          closeIcons.forEach((icon) => icon?.classList.add("hidden"));
          document.body.style.overflow = "";
        }

        if (mobileMenuInner) {
          mobileMenuInner.addEventListener("click", (e) => {
            if (e.target === mobileMenuInner) closeMenu();
          });
        }

        const toggles = [
          document.getElementById("mobile-menu-toggle"),
          document.getElementById("menu-toggle-desktop"),
        ];

        toggles.forEach((toggle) => {
          if (!toggle) return;
          const newToggle = toggle.cloneNode(true) as HTMLElement;
          toggle.parentNode?.replaceChild(newToggle, toggle);
          newToggle.addEventListener("click", () => {
            const isOpen = mobileMenu?.classList.contains("menu-open");
            if (isOpen) closeMenu();
            else openMenu();
          });
        });

        if (mobileMenuBackdrop) {
          const newBackdrop = mobileMenuBackdrop.cloneNode(true) as HTMLElement;
          mobileMenuBackdrop.parentNode?.replaceChild(
            newBackdrop,
            mobileMenuBackdrop,
          );
          newBackdrop.addEventListener("click", closeMenu);
        }

        mobileMenu?.querySelectorAll("a").forEach((link) => {
          link.addEventListener("click", closeMenu);
        });

        const menuSearchToggle = document.getElementById("menu-search-toggle");
        if (menuSearchToggle) {
          const newSearchToggle = menuSearchToggle.cloneNode(
            true,
          ) as HTMLElement;
          menuSearchToggle.parentNode?.replaceChild(
            newSearchToggle,
            menuSearchToggle,
          );
          newSearchToggle.addEventListener("click", () => {
            closeMenu();
            setTimeout(() => {
              const searchToggle =
                document.getElementById("search-toggle-desktop") ||
                document.getElementById("search-toggle-mobile");
              searchToggle?.click();
            }, 100);
          });
        }
      }

      // Search Modal - wrapped for View Transitions
      function initSearchModal() {
        const searchModal = document.getElementById("search-modal");
        const searchBackdrop = document.getElementById("search-backdrop");
        const searchContainer = document.getElementById("search-container");
        const searchToggles = [
          document.getElementById("search-toggle-desktop"),
          document.getElementById("search-toggle-mobile"),
        ];

        let pagefindLoaded = false;

        async function loadPagefind() {
          if (pagefindLoaded) return;
          try {
            if (
              !document.querySelector('link[href="/pagefind/pagefind-ui.css"]')
            ) {
              const link = document.createElement("link");
              link.rel = "stylesheet";
              link.href = "/pagefind/pagefind-ui.css";
              document.head.appendChild(link);
            }
            await new Promise<void>((resolve, reject) => {
              if ((window as any).PagefindUI) {
                resolve();
                return;
              }
              const script = document.createElement("script");
              script.src = "/pagefind/pagefind-ui.js";
              script.onload = () => resolve();
              script.onerror = reject;
              document.head.appendChild(script);
            });
            new (window as any).PagefindUI({
              element: "#search-container",
              showSubResults: true,
              showImages: false,
              excerptLength: 15,
            });
            pagefindLoaded = true;
          } catch (e) {
            console.error("Pagefind load error:", e);
            if (searchContainer) {
              searchContainer.innerHTML = `
                <div class="p-6 text-center text-base-content/60">
                  <p class="mb-2">Search is available after building the index.</p>
                  <p class="text-sm">Run <code class="bg-base-content/10 px-2 py-1 rounded">npm run build:search</code> to enable search in dev mode.</p>
                </div>
              `;
            }
          }
        }

        const searchModalInner = document.getElementById("search-modal-inner");
        if (searchModalInner) {
          searchModalInner.addEventListener("click", (e) => {
            if (e.target === searchModalInner) closeSearch();
          });
        }

        function openSearch() {
          searchModal?.classList.add("search-open");
          document.body.classList.add("search-active");
          document.body.style.overflow = "hidden";
          loadPagefind().then(() => {
            setTimeout(() => {
              const input = searchContainer?.querySelector("input");
              (input as HTMLInputElement)?.focus();
            }, 100);
          });
        }

        function closeSearch() {
          searchModal?.classList.remove("search-open");
          // Remove body class after animations (0.4s)
          setTimeout(() => {
            document.body.classList.remove("search-active");
          }, 400);
          document.body.style.overflow = "";
        }

        searchToggles.forEach((toggle) => {
          if (toggle) {
            const newToggle = toggle.cloneNode(true) as HTMLElement;
            toggle.parentNode?.replaceChild(newToggle, toggle);
            newToggle.addEventListener("click", () => {
              const isOpen = searchModal?.classList.contains("search-open");
              if (isOpen) closeSearch();
              else openSearch();
            });
          }
        });

        if (searchBackdrop) {
          const newBackdrop = searchBackdrop.cloneNode(true) as HTMLElement;
          searchBackdrop.parentNode?.replaceChild(newBackdrop, searchBackdrop);
          newBackdrop.addEventListener("click", closeSearch);
        }
      }

      // Initialize all interactive elements
      initGlobalMenu();
      initSearchModal();

      // =========================================================================
      // OS DETECTION UTILITY
      // =========================================================================
      //
      // Detects if the user is on macOS to display appropriate keyboard shortcuts.
      // Uses the modern User-Agent Client Hints API (navigator.userAgentData) when
      // available, with a fallback to the deprecated navigator.platform for older
      // browsers that don't support the new API.
      //
      // WHY THIS MATTERS:
      // - macOS uses CMD (⌘) as the primary modifier key
      // - Windows/Linux use CTRL as the primary modifier key
      // - Displaying the correct key helps users discover keyboard shortcuts
      //
      // API NOTES:
      // - navigator.userAgentData.platform: Modern API (Chrome 90+, Edge 90+)
      //   Returns "macOS", "Windows", "Linux", etc.
      // - navigator.platform: Deprecated but widely supported fallback
      //   Returns "MacIntel", "Win32", "Linux x86_64", etc.
      //
      // The result is cached to avoid repeated API calls.
      //
      // =========================================================================
      const isMacOS = (function detectMacOS() {
        // Type guard: navigator.userAgentData is not yet in TypeScript's lib.dom.d.ts
        // We cast to 'any' to access it safely, with optional chaining for runtime safety
        const nav =
          typeof navigator !== "undefined" ? (navigator as any) : null;

        // Try modern User-Agent Client Hints API first (not deprecated)
        // This API is available in Chromium-based browsers (Chrome 90+, Edge 90+)
        if (nav?.userAgentData?.platform) {
          return nav.userAgentData.platform.toLowerCase().includes("mac");
        }

        // Fallback to deprecated navigator.platform for older browsers
        // (Safari, Firefox, older Chrome versions)
        // This is still needed for broad compatibility as of 2025
        if (nav?.platform) {
          return nav.platform.toUpperCase().includes("MAC");
        }

        // Default to non-Mac if detection fails (e.g., SSR environment)
        return false;
      })();

      // =========================================================================
      // KEYBOARD SHORTCUT LABEL UPDATERS
      // =========================================================================
      //
      // These functions update the visible keyboard shortcut hints in the UI
      // to show CMD (macOS) or CTRL (Windows/Linux) based on the detected OS.
      //
      // ELEMENTS UPDATED:
      // - #search-shortcut-label: Shows "CMD + K" or "CTRL + K"
      // - #theme-shortcut-label: Shows "CMD + D" or "CTRL + D"
      // - #menu-shortcut-label: Shows "CMD + /" or "CTRL + /"
      //
      // =========================================================================

      /**
       * Updates the search shortcut label (CMD/CTRL + K) based on detected OS.
       * The search modal can be opened with this keyboard shortcut.
       */
      function updateSearchShortcut() {
        const label = document.getElementById("search-shortcut-label");
        if (label) {
          label.textContent = isMacOS ? "CMD + K" : "CTRL + K";
        }
      }
      updateSearchShortcut();

      /**
       * Updates the theme toggle shortcut label (CMD/CTRL + D) based on detected OS.
       * This shortcut toggles between light and dark themes.
       */
      function updateThemeShortcut() {
        const label = document.getElementById("theme-shortcut-label");
        if (label) {
          label.textContent = isMacOS ? "CMD + D" : "CTRL + D";
        }
      }
      updateThemeShortcut();

      /**
       * Updates the menu shortcut label (CMD/CTRL + /) based on detected OS.
       * This shortcut opens the navigation menu overlay.
       */
      function updateMenuShortcut() {
        const label = document.getElementById("menu-shortcut-label");
        if (label) {
          label.textContent = isMacOS ? "CMD + /" : "CTRL + /";
        }
      }
      updateMenuShortcut();

      // Global keyboard shortcuts (only add once)
      if (!(window as any).__keyboardShortcutsInitialized) {
        document.addEventListener("keydown", (e) => {
          const searchModal = document.getElementById("search-modal");
          const mobileMenu = document.getElementById("mobile-menu");

          if (e.key === "Escape") {
            if (searchModal?.classList.contains("search-open")) {
              searchModal.classList.remove("search-open");
              document.body.style.overflow = "";
            } else if (mobileMenu?.classList.contains("menu-open")) {
              mobileMenu.classList.remove("menu-open");
              document.body.classList.remove("mobile-menu-active");
              document.body.style.overflow = "";
            }
          }
          // CMD/CTRL + K: Toggle search
          if ((e.metaKey || e.ctrlKey) && e.key === "k") {
            e.preventDefault();
            if (searchModal?.classList.contains("search-open")) {
              searchModal.classList.remove("search-open");
              setTimeout(() => {
                document.body.classList.remove("search-active");
              }, 400);
              document.body.style.overflow = "";
            } else {
              searchModal?.classList.add("search-open");
              document.body.classList.add("search-active");
              document.body.style.overflow = "hidden";
              // Focus input
              setTimeout(() => {
                const input = searchModal?.querySelector("input");
                (input as HTMLInputElement)?.focus();
              }, 100);
            }
          }
          // CMD/CTRL + D: Toggle dark/light mode
          // Uses shared toggleTheme() function for consistent behavior
          if ((e.metaKey || e.ctrlKey) && e.key === "d") {
            e.preventDefault();
            toggleTheme();
          }
          // CMD/CTRL + /: Toggle menu
          if ((e.metaKey || e.ctrlKey) && e.key === "/") {
            e.preventDefault();
            const menuToggle =
              document.getElementById("menu-toggle-desktop") ||
              document.getElementById("mobile-menu-toggle");
            menuToggle?.click();
          }
        });
        (window as any).__keyboardShortcutsInitialized = true;
      }

      /**
       * =========================================================================
       * IMAGE ZOOM (LIGHTBOX) FEATURE
       * =========================================================================
       *
       * Provides click-to-zoom functionality for images in content areas.
       * When an image is clicked, it displays in a full-screen overlay that
       * can be dismissed by clicking anywhere or pressing Escape.
       *
       * SUPPORTED IMAGE SELECTORS:
       * - .prose img        → Images in markdown/prose content
       * - .md-card-body img → Images in markdown card components
       * - .photo-item img   → Images in photo galleries
       *
       * -------------------------------------------------------------------------
       * VIEW TRANSITIONS COMPATIBILITY
       * -------------------------------------------------------------------------
       *
       * PROBLEM: This function is called on initial page load AND on every
       * astro:page-load event (View Transitions navigation). Without guards,
       * each call adds ADDITIONAL event listeners, causing:
       *
       * - Multiple escape key handlers → multiple close attempts
       * - Multiple overlay click handlers → memory leaks
       * - Multiple image click handlers → multiple zoom opens
       *
       * SOLUTION: Three different patterns for three different cases:
       *
       * 1. INDIVIDUAL IMAGES: Use __zoomInitialized flag on each element
       *    - Check if img.__zoomInitialized exists before adding listener
       *    - Set the flag after adding listener
       *    - Works because images are DOM elements that persist or are new
       *
       * 2. OVERLAY CLICK: Clone the overlay element
       *    - Cloning an element removes all attached event listeners
       *    - Replace original with clone, then add fresh listener
       *    - Safe because overlay is a single element we control
       *
       * 3. ESCAPE KEY: Use global window flag __imageZoomEscapeInitialized
       *    - Document keydown listener is global (survives navigation)
       *    - Only add once, persists throughout session
       *    - Use dynamic overlay lookup in handler (handles cloning)
       *
       * =========================================================================
       */
      function initImageZoom() {
        // ---------------------------------------------------------------------
        // GALLERY STATE - Tracks current gallery and index for navigation
        // ---------------------------------------------------------------------
        // Store state on window to persist across View Transitions
        if (!(window as any).__galleryState) {
          (window as any).__galleryState = {
            images: [] as HTMLElement[],
            currentIndex: 0,
            isGalleryMode: false,
          };
        }
        const galleryState = (window as any).__galleryState;

        // ---------------------------------------------------------------------
        // HELPER FUNCTIONS - Read __galleryState dynamically each call
        // ---------------------------------------------------------------------
        function closeOverlay() {
          const overlay = document.getElementById("zoom-overlay");
          const caption = document.getElementById("zoom-caption");
          if (overlay) {
            overlay.classList.remove("active", "gallery-mode");
            document.body.style.overflow = "";
            (window as any).__galleryState.isGalleryMode = false;
          }
          // Hide caption when closing
          if (caption) {
            caption.classList.remove("visible");
          }
        }

        function showImage(index: number) {
          const overlay = document.getElementById("zoom-overlay");
          const zoomedImg = document.getElementById(
            "zoomed-image",
          ) as HTMLImageElement;
          const counter = document.getElementById("zoom-counter");
          const prevBtn = document.getElementById(
            "zoom-prev",
          ) as HTMLButtonElement;
          const nextBtn = document.getElementById(
            "zoom-next",
          ) as HTMLButtonElement;

          // Caption elements
          const caption = document.getElementById("zoom-caption");
          const captionTitle = document.getElementById("zoom-caption-title");
          const captionDesc = document.getElementById(
            "zoom-caption-description",
          );
          const captionMeta = document.getElementById("zoom-caption-meta");

          const state = (window as any).__galleryState;
          if (!overlay || !zoomedImg || !state.images || !state.images.length)
            return;

          // Clamp index
          index = Math.max(0, Math.min(index, state.images.length - 1));
          state.currentIndex = index;

          const img = state.images[index];
          if (!img) return;
          // Use data-src from parent .photo-item if available (for full-size), else use img src
          const photoItem = img.closest ? img.closest(".photo-item") : null;
          const fullSrc =
            photoItem?.getAttribute("data-src") || img.getAttribute("src");
          const alt =
            photoItem?.getAttribute("data-alt") || img.getAttribute("alt");

          // Get description and metadata from photo-item data attributes
          const description = photoItem?.getAttribute("data-description") || "";
          const location = photoItem?.getAttribute("data-location") || "";
          const camera = photoItem?.getAttribute("data-camera") || "";

          if (fullSrc) {
            zoomedImg.src = fullSrc;
            zoomedImg.alt = alt || "";
          }

          // Update caption (only for gallery images with data)
          if (caption && captionTitle && captionDesc && captionMeta) {
            const hasCaption = alt || description || location || camera;

            if (hasCaption && state.isGalleryMode) {
              captionTitle.textContent = alt || "";
              captionDesc.textContent = description;

              // Build meta line (location · camera)
              const metaParts = [location, camera].filter(Boolean);
              captionMeta.textContent = metaParts.join(" · ");

              caption.classList.add("visible");
            } else {
              caption.classList.remove("visible");
            }
          }

          // Update counter
          if (counter && state.isGalleryMode) {
            counter.textContent = `${index + 1} / ${state.images.length}`;
          }

          // Update button states
          if (prevBtn) prevBtn.disabled = index === 0;
          if (nextBtn) nextBtn.disabled = index === state.images.length - 1;
        }

        function navigatePrev() {
          const state = (window as any).__galleryState;
          if (state.currentIndex > 0) {
            showImage(state.currentIndex - 1);
          }
        }

        function navigateNext() {
          const state = (window as any).__galleryState;
          if (state.currentIndex < state.images.length - 1) {
            showImage(state.currentIndex + 1);
          }
        }

        // ---------------------------------------------------------------------
        // FIND ALL ZOOMABLE IMAGES
        // ---------------------------------------------------------------------
        const allImages = document.querySelectorAll(
          ".prose img, .md-card-body img, .photo-item img",
        );

        // Exit early if no overlay exists
        const overlayCheck = document.getElementById("zoom-overlay");
        if (!overlayCheck) return;

        // ---------------------------------------------------------------------
        // ATTACH CLICK HANDLERS TO IMAGES
        // ---------------------------------------------------------------------
        allImages.forEach((img) => {
          if ((img as any).__zoomInitialized || !img.getAttribute("src"))
            return;
          (img as any).__zoomInitialized = true;

          img.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();

            const overlay = document.getElementById("zoom-overlay");
            if (!overlay) return;

            const state = (window as any).__galleryState;

            // Check if this is part of a photo gallery
            const photoItem = img.closest(".photo-item");
            const isGallery = !!photoItem;

            if (isGallery) {
              // Collect all visible gallery images
              const allGalleryImages = Array.from(
                document.querySelectorAll(".photo-item:not(.hidden) img"),
              ) as HTMLElement[];
              state.images = allGalleryImages;
              state.currentIndex = allGalleryImages.indexOf(img as HTMLElement);
              state.isGalleryMode = true;
              overlay.classList.add("gallery-mode");
            } else {
              // Single image mode
              state.images = [img as HTMLElement];
              state.currentIndex = 0;
              state.isGalleryMode = false;
              overlay.classList.remove("gallery-mode");
            }

            showImage(state.currentIndex);
            overlay.classList.add("active");
            document.body.style.overflow = "hidden";
          });
        });

        // ---------------------------------------------------------------------
        // CLOSE BUTTON HANDLER
        // ---------------------------------------------------------------------
        if (!(window as any).__zoomCloseInitialized) {
          document.addEventListener("click", (e) => {
            const target = e.target as HTMLElement;
            if (target.closest("#zoom-close")) {
              e.stopPropagation();
              closeOverlay();
            }
          });
          (window as any).__zoomCloseInitialized = true;
        }

        // ---------------------------------------------------------------------
        // NAVIGATION BUTTON HANDLERS
        // ---------------------------------------------------------------------
        if (!(window as any).__zoomNavInitialized) {
          document.addEventListener("click", (e) => {
            const target = e.target as HTMLElement;
            if (target.closest("#zoom-prev")) {
              e.stopPropagation();
              navigatePrev();
            } else if (target.closest("#zoom-next")) {
              e.stopPropagation();
              navigateNext();
            }
          });
          (window as any).__zoomNavInitialized = true;
        }

        // ---------------------------------------------------------------------
        // OVERLAY CLICK TO CLOSE (but not on image or buttons)
        // Using document delegation to survive View Transitions
        // ---------------------------------------------------------------------
        if (!(window as any).__imageZoomOverlayInitialized) {
          document.addEventListener("click", (e) => {
            const overlay = document.getElementById("zoom-overlay");
            if (!overlay?.classList.contains("active")) return;

            const target = e.target as HTMLElement;
            // Only close if clicking directly on the overlay background
            if (target.id === "zoom-overlay") {
              closeOverlay();
            }
          });
          (window as any).__imageZoomOverlayInitialized = true;
        }

        // ---------------------------------------------------------------------
        // KEYBOARD NAVIGATION
        // ---------------------------------------------------------------------
        if (!(window as any).__imageZoomKeyboardInitialized) {
          document.addEventListener("keydown", (e) => {
            const overlay = document.getElementById("zoom-overlay");
            if (!overlay?.classList.contains("active")) return;

            switch (e.key) {
              case "Escape":
                closeOverlay();
                break;
              case "ArrowLeft":
                e.preventDefault();
                navigatePrev();
                break;
              case "ArrowRight":
                e.preventDefault();
                navigateNext();
                break;
            }
          });
          (window as any).__imageZoomKeyboardInitialized = true;
        }

        // ---------------------------------------------------------------------
        // MOUSE WHEEL NAVIGATION (horizontal scroll = navigate gallery)
        // ---------------------------------------------------------------------
        if (!(window as any).__imageZoomWheelInitialized) {
          document.addEventListener(
            "wheel",
            (e) => {
              const overlay = document.getElementById("zoom-overlay");
              if (!overlay?.classList.contains("active")) return;

              const state = (window as any).__galleryState;
              if (!state.isGalleryMode) return;

              // Use horizontal scroll (deltaX) or shift+vertical scroll
              const delta =
                e.deltaX !== 0 ? e.deltaX : e.shiftKey ? e.deltaY : 0;

              if (Math.abs(delta) > 30) {
                e.preventDefault();
                if (delta > 0) {
                  navigateNext();
                } else {
                  navigatePrev();
                }
              }
            },
            { passive: false },
          );
          (window as any).__imageZoomWheelInitialized = true;
        }

        // ---------------------------------------------------------------------
        // TOUCH SWIPE SUPPORT & TAP TO CLOSE (Mobile)
        // Using document delegation to survive View Transitions
        // Non-passive to allow preventDefault and stop event propagation
        // ---------------------------------------------------------------------
        if (!(window as any).__imageZoomSwipeInitialized) {
          let touchStartX = 0;
          let touchStartY = 0;
          let touchStartTime = 0;
          let touchStartedOnOverlay = false;

          document.addEventListener(
            "touchstart",
            (e) => {
              const overlay = document.getElementById("zoom-overlay");
              if (!overlay?.classList.contains("active")) {
                touchStartedOnOverlay = false;
                return;
              }

              const target = e.target as HTMLElement;
              // Check if touch started within the overlay
              touchStartedOnOverlay = !!(
                target.closest("#zoom-overlay") || target.id === "zoom-overlay"
              );

              if (touchStartedOnOverlay) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
                // Prevent touch from propagating to page below
                e.preventDefault();
              }
            },
            { passive: false },
          );

          document.addEventListener(
            "touchend",
            (e) => {
              const overlay = document.getElementById("zoom-overlay");
              if (
                !overlay?.classList.contains("active") ||
                !touchStartedOnOverlay
              )
                return;

              const target = e.target as HTMLElement;
              const state = (window as any).__galleryState;
              const touchEndX = e.changedTouches[0].clientX;
              const touchEndY = e.changedTouches[0].clientY;
              const diffX = touchStartX - touchEndX;
              const diffY = touchStartY - touchEndY;
              const absDiffX = Math.abs(diffX);
              const absDiffY = Math.abs(diffY);
              const duration = Date.now() - touchStartTime;

              // Prevent touch from propagating to page below
              e.preventDefault();

              // Check if it's a tap (quick, small movement)
              if (duration < 300 && absDiffX < 15 && absDiffY < 15) {
                // Close if tapping on overlay background (not on interactive elements)
                const isInteractive = target.closest(
                  ".zoom-controls, .zoomed-image, .zoom-close",
                );
                if (!isInteractive) {
                  closeOverlay();
                  return;
                }
              }

              // Check for swipe gestures (only in gallery mode)
              if (
                state.isGalleryMode &&
                absDiffX > 50 &&
                absDiffX > absDiffY * 1.5
              ) {
                if (diffX > 0) {
                  navigateNext(); // Swipe left = next
                } else {
                  navigatePrev(); // Swipe right = prev
                }
              }
            },
            { passive: false },
          );

          (window as any).__imageZoomSwipeInitialized = true;
        }

        // ---------------------------------------------------------------------
        // MOUSE DRAG NAVIGATION (click and drag to navigate gallery)
        // ---------------------------------------------------------------------
        if (!(window as any).__imageZoomMouseDragInitialized) {
          let isDragging = false;
          let dragStartX = 0;
          let dragStartY = 0;

          document.addEventListener("mousedown", (e) => {
            const overlay = document.getElementById("zoom-overlay");
            if (!overlay?.classList.contains("active")) return;

            const state = (window as any).__galleryState;
            if (!state.isGalleryMode) return;

            const target = e.target as HTMLElement;
            // Only start drag on the image itself
            if (target.classList.contains("zoomed-image")) {
              isDragging = true;
              dragStartX = e.clientX;
              dragStartY = e.clientY;
              e.preventDefault();
            }
          });

          document.addEventListener("mouseup", (e) => {
            if (!isDragging) return;
            isDragging = false;

            const overlay = document.getElementById("zoom-overlay");
            if (!overlay?.classList.contains("active")) return;

            const state = (window as any).__galleryState;
            if (!state.isGalleryMode) return;

            const diffX = dragStartX - e.clientX;
            const diffY = dragStartY - e.clientY;
            const absDiffX = Math.abs(diffX);
            const absDiffY = Math.abs(diffY);

            // Check for horizontal drag (navigate gallery)
            if (absDiffX > 50 && absDiffX > absDiffY * 1.5) {
              if (diffX > 0) {
                navigateNext(); // Drag left = next
              } else {
                navigatePrev(); // Drag right = prev
              }
            }
          });

          // Prevent default drag behavior on zoomed image
          document.addEventListener("dragstart", (e) => {
            if ((e.target as HTMLElement).classList.contains("zoomed-image")) {
              e.preventDefault();
            }
          });

          (window as any).__imageZoomMouseDragInitialized = true;
        }
      }

      // Run on initial page load
      initImageZoom();

      // =========================================================================
      // CONSOLIDATED VIEW TRANSITIONS HANDLER
      // =========================================================================
      //
      // Single listener for astro:page-load that reinitializes all interactive
      // elements after View Transitions navigation. Consolidating into one
      // listener is cleaner and ensures consistent initialization order.
      //
      // INITIALIZATION ORDER:
      // 1. restoreTheme() - Restore user's theme preference from localStorage
      // 2. initThemeToggle() - Re-attach click handlers to theme buttons
      // 3. initGlobalMenu() - Re-attach menu toggle handlers
      // 4. initSearchModal() - Re-attach search modal handlers
      // 5. updateShortcuts() - Update keyboard shortcut labels for OS
      // 6. initImageZoom() - Attach handlers to newly loaded images
      //
      // =========================================================================
      document.addEventListener("astro:page-load", () => {
        // Restore theme (View Transitions may reset data-theme)
        restoreTheme();

        // Reinitialize interactive elements
        initThemeToggle();
        initGlobalMenu();
        initSearchModal();
        initImageZoom();

        // Update shortcut labels for current OS
        updateSearchShortcut();
        updateThemeShortcut();
        updateMenuShortcut();
      });
    </script>
  </body>
</html>

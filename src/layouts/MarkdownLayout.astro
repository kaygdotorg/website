---
import BaseLayout from "./BaseLayout.astro";
import { Image } from "astro:assets";
import { formatDate, getRelativeTime } from "../utils/dates";
import { getExcerpt } from "../utils/markdown";

interface Props {
  title: string;
  description?: string;
  entry?: any; // Add entry prop to extract description
  createdDate?: Date | string;
  lastEdited?: Date | string;
  readingTime?: number;
  backlinks?: Array<{ title: string; href: string }>;
  /** True backlinks: pages that link TO this page */
  trueBacklinks?: Array<{ source: string; title: string; collection: string }>;
  /** Graph data for local graph visualization */
  graphData?: { nodes: Array<{ id: string; title: string; collection: string }>; links: Array<{ source: string; target: string }> };
  /** Current page path for graph highlighting */
  currentPath?: string;
  coverImage?: any;
}

const {
  title,
  description: propDescription,
  entry,
  createdDate,
  lastEdited,
  readingTime,
  backlinks = [],
  trueBacklinks = [],
  graphData = { nodes: [], links: [] },
  currentPath = "",
  coverImage,
} = Astro.props;

// Use description from props, or extract from entry body, or fallback
const description =
  propDescription || (entry?.body ? getExcerpt(entry.body) : undefined);

// Display control logic
const displayTOC = entry?.data?.["display-table-of-contents"] !== false;
const displayDates = entry?.data?.["display-dates"] !== false;
const displayComments = entry?.data?.["display-comments"] !== false;

const relativeLastEdited = lastEdited ? getRelativeTime(lastEdited) : null;
const formattedLastEdited = lastEdited ? formatDate(lastEdited) : null;
const formattedCreatedDate = createdDate ? formatDate(createdDate) : null;

// In-progress state
const displayInProgress = entry?.data?.["display-in-progress"] === true;

// Generate Article JSON-LD schema for blog posts (only if we have a date)
const articleSchema = createdDate ? {
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": title,
  "description": description || "",
  "datePublished": new Date(createdDate).toISOString(),
  ...(lastEdited && { "dateModified": new Date(lastEdited).toISOString() }),
  ...(coverImage && { 
    "image": typeof coverImage === "string" 
      ? `${Astro.url.origin}${coverImage}` 
      : `${Astro.url.origin}${coverImage.src}` 
  }),
  "author": {
    "@type": "Person",
    "@id": `${Astro.url.origin}/#person`,
    "name": "K Gopal Krishna"
  },
  "publisher": {
    "@type": "Person",
    "@id": `${Astro.url.origin}/#person`,
    "name": "K Gopal Krishna"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": Astro.url.href
  }
} : null;

// Construct GitHub history URL using the entry's relative file path
// This allows users to view the commit history for the specific markdown file
const githubUrl = entry?.filePath 
  ? `https://github.com/kaygdotorg/website/commits/main/${entry.filePath}`
  : null;

---

<BaseLayout title={title} description={description} displayInProgress={displayInProgress} ogImage={typeof coverImage === "string" ? coverImage : coverImage?.src}>
  {/* Article JSON-LD Schema - only rendered for date-based content like blog posts */}
  {articleSchema && (
    <script type="application/ld+json" set:html={JSON.stringify(articleSchema)} />
  )}

  <div class="md-page-container">
    <!-- Unified Single Card for entire page -->
    <div class="frosted-card md-unified-card">
      <!-- Featured Image at top of card -->
      <!-- GIFs use plain <img> to preserve animation; other formats use <Image /> for optimization -->
      {
        coverImage && (
          <div class="md-card-featured-image">
            {typeof coverImage === "string" ? (
              <img src={coverImage} alt={title} loading="lazy" decoding="async" />
            ) : coverImage.format === "gif" ? (
              <img
                src={coverImage.src}
                alt={title}
                loading="lazy"
                decoding="async"
              />
            ) : (
              <Image
                src={coverImage}
                alt={title}
                loading="lazy"
                decoding="async"
              />
            )}
          </div>
        )
      }

      <!-- Title Section -->
      <div class="md-card-title">
        <h1>{title}</h1>
        <div class="md-card-metadata">
          {/* Reading time */}
          {
            readingTime && (
              <span title="Estimated reading time">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                  />
                </svg>
                {readingTime} min read
              </span>
            )
          }

          {/* Created date */}
          {
            displayDates && formattedCreatedDate && (
              <>
                {readingTime && <span class="opacity-20">•</span>}
                <span title="Published" data-pagefind-meta="date">
                  <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
                    />
                  </svg>
                  {formattedCreatedDate}
                </span>
              </>
            )
          }

          {/* Last edited - tappable to show full date */}
          {
            displayDates && relativeLastEdited && (
              <>
                {(readingTime || (displayDates && formattedCreatedDate)) && <span class="opacity-20">•</span>}
                <div class="flex items-center gap-3">
                  <span
                    class="last-edited-toggle cursor-pointer inline-flex items-center gap-1.5 hover:text-base-content transition-colors"
                    data-relative={`Updated ${relativeLastEdited}`}
                    data-absolute={`Updated ${formattedLastEdited}`}
                  >
                    <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-4 h-4">
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                      />
                    </svg>
                    <span class="last-edited-text">
                      Updated {relativeLastEdited}
                    </span>
                  </span>
                  
                  {githubUrl && (
                    <>
                      <span class="opacity-20">•</span>
                      <a 
                        href={githubUrl}
                        target="_blank"
                        rel="noopener noreferrer"
                        class="inline-flex items-center gap-1.5 hover:text-base-content transition-colors opacity-100"
                        title="View history on GitHub"
                      >
                        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-4 h-4">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        History
                      </a>
                    </>
                  )}
                </div>
              </>
            )
          }
        </div>
      </div>

      <!-- Divider -->
      <hr class="md-section-divider" />

      <!-- Three-column layout wrapper for desktop sidebars -->
      <div class="md-content-wrapper">
        <!-- Left Sidebar: Table of Contents (desktop only) -->
        {
          displayTOC && (
            <aside class="md-sidebar md-sidebar-left">
              <div class="md-sidebar-sticky">
                <div class="md-sidebar-content toc-window-container">
                  <!-- 5-item sliding window: prev-2, prev, current, next, next-2 -->
                  <div class="toc-window">
                    <a href="#" class="toc-window-item toc-far-prev" data-index="-2"></a>
                    <a href="#" class="toc-window-item toc-prev" data-index="-1"></a>
                    <a href="#" class="toc-window-item toc-current" data-index="0"></a>
                    <a href="#" class="toc-window-item toc-next" data-index="1"></a>
                    <a href="#" class="toc-window-item toc-far-next" data-index="2"></a>
                  </div>
                </div>
              </div>
            </aside>
          )
        }

        <!-- Main content column -->
        <div class="md-main-content">
          <!-- Table of Contents Section - Mobile only, Collapsible -->
          {
            displayTOC && (
              <>
                <section class="md-section md-card-collapsible md-card-toc md-toc-linear" id="table-of-contents">
                  <div class="md-card-header" onclick="toggleCard('table-of-contents')">
                    <h2 class="section-heading" id="toc-heading" data-anchor="table-of-contents"><span class="heading-text">Table of contents</span><a class="heading-link" href="#table-of-contents" aria-label="Link to Table of contents"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
                    <svg
                      class="md-card-toggle"
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke="currentColor"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M19 9l-7 7-7-7"
                      />
                    </svg>
                  </div>
                  <div class="md-card-content">
                    <ul id="toc-list">
                      <!-- Populated by JS -->
                    </ul>
                  </div>
                </section>
                <hr class="md-section-divider md-toc-linear-divider" />
              </>
            )
          }

          <!-- Content Section - Not collapsible -->
      <div class="md-section md-card-body" id="content-card">
        <div class="md-card-content" id="markdown-content">
          <slot />
        </div>
        
        {/* Tags Section at bottom of content */}
        {entry?.data?.tags && entry.data.tags.length > 0 && (
          <div class="md-tags-footer mt-12 pt-8 border-t border-base-content/5">
            <div class="md-card-content">
              <div class="flex items-center gap-3 text-sm text-base-content/40">
                <span>Filed under</span>
                <div class="flex flex-wrap gap-2">
                  {entry.data.tags.map((tag: string) => (
                    <span class="px-2.5 py-0.5 rounded-lg bg-base-content/5 text-base-content/50 hover:text-base-content hover:bg-base-content/10 transition-all cursor-default">
                      #{tag}
                    </span>
                  ))}
                </div>
              </div>
            </div>
          </div>
        )}
      </div>

          <!-- Navigation Section -->
          {
            backlinks.length > 0 && (
              <>
                <hr class="md-section-divider" />
                <nav class="md-section md-navigation" id="navigation-card">
                  <div class="md-navigation-content">
                    {backlinks.map((link) => (
                      <a href={link.href} class="md-nav-link">{link.title}</a>
                    ))}
                  </div>
                </nav>
              </>
            )
          }

          <!-- Backlinks Section - Always visible at bottom -->
          {
            trueBacklinks.length > 0 && (
              <>
                <hr class="md-section-divider" />
                <section class="md-section md-backlinks" id="backlinks">
                  <div class="md-backlinks-header">
                    <h3 class="section-heading" id="backlinks-heading" data-anchor="backlinks"><span class="heading-text">Linked from</span> <span class="md-backlinks-count">{trueBacklinks.length}</span><a class="heading-link" href="#backlinks" aria-label="Link to Backlinks"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
                  </div>
                  <div class="md-backlinks-content">
                    {trueBacklinks.map((link) => (
                      <a href={link.source} class="md-backlink-pill" data-collection={link.collection}>
                        {link.title}
                      </a>
                    ))}
                  </div>
                </section>
              </>
            )
          }

          <!-- Local Graph Section - Linear (morphs with sidebar) -->
          {
            graphData.nodes.length > 1 && (
              <>
                <hr class="md-section-divider md-graph-linear-divider" />
                <section class="md-section md-graph md-graph-linear" id="local-graph">
                  <div class="md-graph-header">
                    <h3 class="section-heading" id="local-graph-heading" data-anchor="local-graph"><span class="heading-text">Local Graph</span><a class="heading-link" href="#local-graph" aria-label="Link to Local Graph"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
                  </div>
                  <div class="md-graph-container" data-current={currentPath} data-graph={JSON.stringify(graphData)}>
                    <canvas></canvas>
                  </div>
                </section>
              </>
            )
          }

        </div><!-- End md-main-content -->

        <!-- Right Sidebar: Local Graph (desktop only) -->
        {
          graphData.nodes.length > 1 && (
            <aside class="md-sidebar md-sidebar-right">
              <div class="md-sidebar-sticky">
                <div class="md-sidebar-content">
                  <div class="md-graph-container-sidebar" data-current={currentPath} data-graph={JSON.stringify(graphData)}>
                    <canvas></canvas>
                  </div>
                </div>
              </div>
            </aside>
          )
        }

      </div><!-- End md-content-wrapper -->

    </div>

    <!-- Comments Section - Separate Card -->
    {
      displayComments && (
        <section class="frosted-card md-comments-card" id="comments">
          <div class="md-comments-header">
            <h2 class="section-heading" id="comments-heading" data-anchor="comments"><span class="heading-text">Comments</span><a class="heading-link" href="#comments" aria-label="Link to Comments"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
          </div>
          <div class="md-card-content">
            <div id="remark42"></div>
          </div>
        </section>
      )
    }
  </div>

  <script is:inline>
    // Toggle collapsible cards
    function toggleCard(cardId) {
      const card = document.getElementById(cardId);
      if (card) {
        card.classList.toggle("collapsed");
      }
    }

    // Wrap heading text content in spans for squiggly underline targeting
    function wrapHeadingText() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const headings = content.querySelectorAll("h2, h3, h4");
      headings.forEach((heading) => {
        // Skip if already wrapped
        if (heading.querySelector(".heading-text")) return;

        // Get the heading link if present
        const headingLink = heading.querySelector(".heading-link");

        // Create wrapper span for text content only
        const textSpan = document.createElement("span");
        textSpan.className = "heading-text";

        // Move all child nodes except .heading-link into the span
        const nodesToMove = [];
        heading.childNodes.forEach((node) => {
          if (
            node !== headingLink &&
            !node.classList?.contains("heading-link")
          ) {
            nodesToMove.push(node);
          }
        });

        nodesToMove.forEach((node) => textSpan.appendChild(node));
        heading.insertBefore(textSpan, heading.firstChild);
      });
    }

    // Generate TOC from headings (populates mobile ToC)
    function generateTOC() {
      const content = document.getElementById("markdown-content");
      const tocList = document.getElementById("toc-list");
      if (!content) return;

      const headings = content.querySelectorAll("h2, h3");

      if (headings.length === 0) {
        // Hide TOC if no headings
        document.getElementById("table-of-contents")?.classList.add("collapsed");
        return;
      }

      // Clear existing TOC to prevent duplicates on re-init
      if (tocList) tocList.innerHTML = "";

      headings.forEach((heading, index) => {
        // Add ID to heading if not present
        if (!heading.id) {
          heading.id = `heading-${index}`;
        }

        const tagName = heading.tagName.toLowerCase();
        const textSpan = heading.querySelector(".heading-text");
        const text = textSpan ? textSpan.textContent : heading.textContent;

        // Mobile ToC
        if (tocList) {
          const li = document.createElement("li");
          li.className = `toc-level-${tagName === "h2" ? "2" : "3"}`;
          const a = document.createElement("a");
          a.href = `#${heading.id}`;
          a.textContent = text;
          li.appendChild(a);
          tocList.appendChild(li);
        }
      });
    }

    // Sidebar ToC: 5-item sliding window with active heading tracking
    function initSidebarTocWindow() {
      const content = document.getElementById("markdown-content");
      const tocWindow = document.querySelector(".toc-window");
      const farPrevItem = document.querySelector(".toc-far-prev");
      const prevItem = document.querySelector(".toc-prev");
      const currentItem = document.querySelector(".toc-current");
      const nextItem = document.querySelector(".toc-next");
      const farNextItem = document.querySelector(".toc-far-next");
      
      if (!content || !tocWindow || !currentItem) return;

      const headings = Array.from(content.querySelectorAll("h2, h3"));
      if (headings.length === 0) return;

      let currentIndex = 0;
      let lastIndex = -1;

      // Build heading data
      const headingData = headings.map((h, i) => {
        const textSpan = h.querySelector(".heading-text");
        return {
          id: h.id,
          text: textSpan ? textSpan.textContent : h.textContent,
          element: h
        };
      });

      function updateItem(item, data) {
        if (!item) return;
        if (data) {
          item.textContent = data.text;
          item.href = `#${data.id}`;
        } else {
          item.textContent = '';
          item.href = '#';
        }
      }

      function updateTocWindow(newIndex, direction) {
        const farPrev = headingData[newIndex - 2];
        const prev = headingData[newIndex - 1];
        const curr = headingData[newIndex];
        const next = headingData[newIndex + 1];
        const farNext = headingData[newIndex + 2];

        // Add animation class
        if (direction !== 0) {
          tocWindow.classList.remove('sliding-up', 'sliding-down');
          tocWindow.classList.add(direction > 0 ? 'sliding-up' : 'sliding-down');
          setTimeout(() => tocWindow.classList.remove('sliding-up', 'sliding-down'), 400);
        }

        updateItem(farPrevItem, farPrev);
        updateItem(prevItem, prev);
        updateItem(currentItem, curr);
        updateItem(nextItem, next);
        updateItem(farNextItem, farNext);
      }

      // Initialize with first heading
      updateTocWindow(0, 0);

      // IntersectionObserver to track active heading
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const index = headings.indexOf(entry.target);
            if (index !== -1 && index !== lastIndex) {
              const direction = index > lastIndex ? 1 : -1;
              lastIndex = index;
              currentIndex = index;
              updateTocWindow(index, direction);
            }
          }
        });
      }, {
        rootMargin: '-20% 0px -70% 0px',
        threshold: 0
      });

      headings.forEach(h => observer.observe(h));
    }

    // Scroll Progress Button Logic
    function initScrollProgress() {
      const btn = document.getElementById("scroll-progress-btn");
      const progressFill = document.querySelector(".scroll-progress-fill");
      const downIcon = document.querySelector(
        ".scroll-progress-icon.scroll-down",
      );
      const upIcon = document.querySelector(".scroll-progress-icon.scroll-up");

      if (!btn || !progressFill || !downIcon || !upIcon) return;

      // Show the button (it's hidden by default in BaseLayout)
      btn.classList.remove("hidden");

      const circumference = 2 * Math.PI * 16; // r=16
      progressFill.style.strokeDasharray = String(circumference);
      progressFill.style.strokeDashoffset = String(circumference);

      // Track current scroll direction
      let shouldScrollDown = true;

      function updateScrollProgress() {
        const scrollTop = window.scrollY;
        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight;
        const scrollPercent = docHeight > 0 ? scrollTop / docHeight : 0;

        // Update progress ring
        const offset = circumference - scrollPercent * circumference;
        progressFill.style.strokeDashoffset = String(offset);

        // Determine direction: if in top 1/3, show down arrow; else show up arrow
        shouldScrollDown = scrollPercent < 0.33;

        if (shouldScrollDown) {
          downIcon.classList.remove("hidden");
          upIcon.classList.add("hidden");
        } else {
          downIcon.classList.add("hidden");
          upIcon.classList.remove("hidden");
        }
      }

      // Handle click
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();

        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight;

        if (shouldScrollDown) {
          // Scroll to bottom
          window.scrollTo({ top: docHeight, behavior: "smooth" });
        } else {
          // Scroll to top
          window.scrollTo({ top: 0, behavior: "smooth" });
        }
      });

      // Listen for scroll
      window.addEventListener("scroll", updateScrollProgress, {
        passive: true,
      });

      // Initial update
      updateScrollProgress();
    }

    // Last edited toggle (tap to show full date)
    function initLastEditedToggle() {
      const toggleEl = document.querySelector(".last-edited-toggle");
      if (!toggleEl) return;

      const textEl = toggleEl.querySelector(".last-edited-text");
      const relativeText = toggleEl.getAttribute("data-relative");
      const absoluteText = toggleEl.getAttribute("data-absolute");

      let showingRelative = true;

      toggleEl.addEventListener("click", () => {
        showingRelative = !showingRelative;
        if (textEl) {
          textEl.textContent = showingRelative ? relativeText : absoluteText;
        }
      });
    }

    // Initialize videos for autoplay (like Ghost)
    function initVideoAutoplay() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const videos = content.querySelectorAll("video");
      videos.forEach((video) => {
        video.muted = true;
        video.loop = true;
        video.playsInline = true;
        video.autoplay = true;
        video.play().catch(() => {
          // Autoplay blocked, ignore
        });
      });
    }

    // Sidebar mode morphing - gradual fade based on scroll position
    function initSidebarMorphing() {
      const linearToc = document.querySelector('.md-toc-linear');
      const linearTocDivider = document.querySelector('.md-toc-linear-divider');
      const linearGraph = document.querySelector('.md-graph-linear');
      const linearGraphDivider = document.querySelector('.md-graph-linear-divider');
      const sidebars = document.querySelectorAll('.md-sidebar');
      const markdownContent = document.getElementById('markdown-content');
      const navSection = document.getElementById('navigation-card');
      
      if (!linearToc || !markdownContent || !sidebars.length) return;

      // Find the last heading in the article content
      const headings = markdownContent.querySelectorAll('h2, h3, h4');
      const lastHeading = headings.length > 0 ? headings[headings.length - 1] : null;

      function clamp(val, min, max) {
        return Math.min(Math.max(val, min), max);
      }

      function updateOpacity() {
        const linearTocRect = linearToc.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        
        // Calculate fade-in progress (0 to 1) as ToC scrolls out of view
        // Start fading when ToC bottom reaches 50% of viewport, complete at 20%
        const fadeInStart = viewportHeight * 0.5;
        const fadeInEnd = viewportHeight * 0.2;
        const fadeInProgress = clamp((fadeInStart - linearTocRect.bottom) / (fadeInStart - fadeInEnd), 0, 1);
        
        // Calculate fade-out progress (1 to 0) as we approach bottom
        let fadeOutProgress = 1;
        if (navSection) {
          const navRect = navSection.getBoundingClientRect();
          // Start fading out when nav reaches 90% of viewport, complete at 60%
          const fadeOutStart = viewportHeight * 0.9;
          const fadeOutEnd = viewportHeight * 0.6;
          fadeOutProgress = clamp((navRect.top - fadeOutEnd) / (fadeOutStart - fadeOutEnd), 0, 1);
        } else if (lastHeading) {
          const lastHeadingRect = lastHeading.getBoundingClientRect();
          const fadeOutStart = viewportHeight * 0.7;
          const fadeOutEnd = viewportHeight * 0.4;
          fadeOutProgress = clamp((lastHeadingRect.top - fadeOutEnd) / (fadeOutStart - fadeOutEnd), 0, 1);
        }

        // Combined sidebar opacity: fade in as we scroll past ToC, fade out at bottom
        const sidebarOpacity = fadeInProgress * fadeOutProgress;
        // Linear elements are inverse of sidebar
        const linearOpacity = 1 - sidebarOpacity;

        // Toggle sidebar visibility class (CSS handles faded effect + hover)
        const shouldShowSidebars = sidebarOpacity > 0.1;
        sidebars.forEach(sidebar => {
          sidebar.classList.toggle('sidebar-visible', shouldShowSidebars);
          sidebar.style.pointerEvents = shouldShowSidebars ? 'auto' : 'none';
        });

        // Apply opacity to linear ToC
        linearToc.style.opacity = linearOpacity;
        linearToc.style.pointerEvents = linearOpacity > 0.1 ? 'auto' : 'none';
        if (linearTocDivider) {
          linearTocDivider.style.opacity = linearOpacity;
        }

        // Apply opacity to linear Graph
        if (linearGraph) {
          linearGraph.style.opacity = linearOpacity;
          linearGraph.style.pointerEvents = linearOpacity > 0.1 ? 'auto' : 'none';
        }
        if (linearGraphDivider) {
          linearGraphDivider.style.opacity = linearOpacity;
        }
      }

      window.addEventListener('scroll', updateOpacity, { passive: true });
      window.addEventListener('resize', updateOpacity, { passive: true });
      updateOpacity();
    }

    // Initialize all markdown features
    function initMarkdownFeatures() {
      wrapHeadingText();
      generateTOC();
      initSidebarTocWindow();
      initCallouts();
      initScrollProgress();
      initLastEditedToggle();
      initVideoAutoplay();
      initSidebarMorphing();

      // Initialize Clipboard Links
      const content = document.getElementById("markdown-content");
      if (content && !content.dataset.clipboardInitialized) {
        initHeadingClipboard(content);
        content.dataset.clipboardInitialized = "true";
      }
    }

    // Transform Obsidian-style [!TYPE] or standard **Type:** markers into floating cards
    function initCallouts() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const blockquotes = content.querySelectorAll("blockquote");
      blockquotes.forEach((bq) => {
        // Find the first paragraph or direct text node
        const firstP = bq.querySelector("p") || bq;
        const text = firstP.innerHTML.trim();

        // 1. Match [!TYPE] or [!TYPE] Title
        // 2. Match **Type:** or **Type**
        const obsidianMatch = text.match(/^\[!(\w+)\]\s*(.*)/i);
        const boldMatch = text.match(/^<strong>(\w+):?<\/strong>\s*(.*)/i);

        const match = obsidianMatch || boldMatch;

        if (match) {
          const type = match[1].toLowerCase();
          const title = match[2];

          bq.classList.add("callout-card", `callout-${type}`);

          // Create the header with italicized type label
          const header = document.createElement("div");
          header.className = "callout-header";

          const typeLabel = document.createElement("span");
          typeLabel.className = "callout-type";
          typeLabel.innerHTML = `<em>${type}</em>`;
          header.appendChild(typeLabel);

          if (title && title.trim() !== "") {
            const titleSpan = document.createElement("span");
            titleSpan.className = "callout-title";
            titleSpan.innerHTML = title;
            header.appendChild(titleSpan);
          }

          // Prepend header
          bq.insertBefore(header, bq.firstChild);

          // Clean up the raw marker text from the first paragraph/node
          if (obsidianMatch) {
            firstP.innerHTML = firstP.innerHTML
              .replace(/^\[!(\w+)\]\s*(.*)/i, "")
              .trim();
          } else if (boldMatch) {
            firstP.innerHTML = firstP.innerHTML
              .replace(/^<strong>(\w+):?<\/strong>\s*(.*)/i, "")
              .trim();
          }

          // Remove paragraph if it's now empty
          if (firstP.innerHTML === "" && firstP !== bq) {
            firstP.remove();
          }
        }
      });
    }

    // Helper for clipboard initialization
    function initHeadingClipboard(content) {
      function copyHeadingLink(heading) {
        if (heading && heading.id) {
          const url = `${window.location.origin}${window.location.pathname}#${heading.id}`;
          heading.classList.add("tapped");
          setTimeout(() => heading.classList.remove("tapped"), 3000);

          if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard
              .writeText(url)
              .then(() => showToast("Link copied to clipboard!"))
              .catch(() => fallbackCopyTextToClipboard(url));
          } else {
            fallbackCopyTextToClipboard(url);
          }
        }
      }

      function fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-9999px";
        textArea.style.top = "0";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
          if (document.execCommand("copy"))
            showToast("Link copied to clipboard!");
        } catch (err) {}
        document.body.removeChild(textArea);
      }

      function handleHeadingInteraction(e) {
        const link = e.target.closest(".heading-link");
        if (link) {
          e.preventDefault();
          e.stopPropagation();
          copyHeadingLink(link.closest("h1, h2, h3, h4, h5, h6"));
          return;
        }
        const heading = e.target.closest("h2, h3, h4");
        if (heading && !e.target.closest("a:not(.heading-link)")) {
          e.preventDefault();
          e.stopPropagation();
          copyHeadingLink(heading);
        }
      }

      let touchStartX = 0,
        touchStartY = 0,
        touchStartTime = 0;
      content.addEventListener(
        "touchstart",
        (e) => {
          const touch = e.changedTouches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          touchStartTime = Date.now();
        },
        { passive: true },
      );

      content.addEventListener(
        "touchend",
        (e) => {
          const touch = e.changedTouches[0];
          const dx = Math.abs(touch.clientX - touchStartX);
          const dy = Math.abs(touch.clientY - touchStartY);
          const dt = Date.now() - touchStartTime;
          if (dx < 10 && dy < 10 && dt < 300) {
            const heading = e.target.closest("h2, h3, h4");
            const link = e.target.closest(".heading-link");
            if (heading || link) {
              e.preventDefault();
              handleHeadingInteraction(e);
            }
          }
        },
        { passive: false },
      );

      content.addEventListener("click", handleHeadingInteraction);
    }

    // Initialize on load and on page transitions
    document.addEventListener("DOMContentLoaded", initMarkdownFeatures);
    document.addEventListener("astro:page-load", initMarkdownFeatures);

    // Initialize section heading copy-link functionality (ToC, Backlinks, Local Graph, Comments)
    function initSectionHeadingClipboard() {
      const sectionHeadings = document.querySelectorAll('.section-heading');
      
      sectionHeadings.forEach(heading => {
        const anchor = heading.dataset.anchor;
        if (!anchor) return;
        
        // Give heading an ID for the copy function
        heading.id = anchor;
        
        function copySectionLink(e) {
          // Don't copy if clicking collapse toggle
          if (e.target.closest('.md-card-toggle')) return;
          
          e.preventDefault();
          e.stopPropagation();
          
          const url = `${window.location.origin}${window.location.pathname}#${anchor}`;
          heading.classList.add("tapped");
          setTimeout(() => heading.classList.remove("tapped"), 1500); // Match toast duration
          
          if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(url)
              .then(() => showToast("Link copied to clipboard!"))
              .catch(() => {
                fallbackCopy(url);
              });
          } else {
            fallbackCopy(url);
          }
        }
        
        function fallbackCopy(text) {
          const textArea = document.createElement("textarea");
          textArea.value = text;
          textArea.style.position = "fixed";
          textArea.style.left = "-9999px";
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          try {
            if (document.execCommand("copy")) showToast("Link copied to clipboard!");
          } catch (err) {}
          document.body.removeChild(textArea);
        }
        
        // Click on heading or link icon
        heading.addEventListener('click', copySectionLink);
        
        // Touch support
        let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
        heading.addEventListener('touchstart', (e) => {
          const touch = e.changedTouches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          touchStartTime = Date.now();
        }, { passive: true });
        
        heading.addEventListener('touchend', (e) => {
          const touch = e.changedTouches[0];
          const dx = Math.abs(touch.clientX - touchStartX);
          const dy = Math.abs(touch.clientY - touchStartY);
          const dt = Date.now() - touchStartTime;
          if (dx < 10 && dy < 10 && dt < 300) {
            copySectionLink(e);
          }
        }, { passive: false });
      });
    }
    
    document.addEventListener("DOMContentLoaded", initSectionHeadingClipboard);
    document.addEventListener("astro:page-load", initSectionHeadingClipboard);

    function showToast(message) {
      let toast = document.getElementById("toast-notification");
      if (!toast) {
        toast = document.createElement("div");
        toast.id = "toast-notification";
        toast.className = "toast-notification";
        document.body.appendChild(toast);
      }

      toast.textContent = message;
      toast.classList.add("show");

      setTimeout(() => {
        toast.classList.remove("show");
      }, 1500);
    }

    // Make toggleCard available globally (safer assignment)
    if (typeof window.toggleCard === "undefined") {
      window.toggleCard = toggleCard;
    }
  </script>

  <!-- Remark42 Comments Scripts (only loaded if comments container exists) -->
  <script is:inline>
    (function () {
      const STATE_KEY = "__remark42State";
      const state = (window[STATE_KEY] = window[STATE_KEY] || {
        scriptsLoaded: false,
        themeObserver: null,
      });

      function currentTheme() {
        return document.documentElement.getAttribute("data-theme") === "light"
          ? "light"
          : "dark";
      }

      function setRemarkConfig() {
        window.remark_config = {
          host: "https://remark42.kayg.org",
          site_id: "kayg.org",
          components: ["embed"],
          max_shown_comments: 15,
          theme: currentTheme(),
          page_title: document.title,
        };
      }

      function loadScriptsOnce() {
        if (state.scriptsLoaded) return;
        state.scriptsLoaded = true;

        // Load remark42 embed script (official loader, minified)
        !(function (e, n) {
          for (var o = 0; o < e.length; o++) {
            var r = n.createElement("script"),
              c = ".js",
              d = n.head || n.body;
            ("noModule" in r
              ? ((r.type = "module"), (c = ".mjs"))
              : (r.async = !0),
              (r.defer = !0),
              (r.src = remark_config.host + "/web/" + e[o] + c),
              d.appendChild(r));
          }
        })(remark_config.components || ["embed"], document);
      }

      function ensureThemeSync() {
        if (state.themeObserver) return;
        state.themeObserver = new MutationObserver((mutations) => {
          for (const mutation of mutations) {
            if (mutation.attributeName === "data-theme" && window.REMARK42) {
              window.REMARK42.changeTheme(currentTheme());
            }
          }
        });
        state.themeObserver.observe(document.documentElement, { attributes: true });
      }

      function mountIfPossible() {
        const container = document.getElementById("remark42");
        if (!container) return;

        // View Transitions can swap the container while keeping scripts.
        // If Remark42 is already loaded, remount into the new container.
        if (window.REMARK42 && typeof window.REMARK42.createInstance === "function") {
          window.REMARK42.createInstance(window.remark_config);
        }
      }

      function initRemark42() {
        if (!document.getElementById("remark42")) return;
        setRemarkConfig();
        loadScriptsOnce();
        ensureThemeSync();
        mountIfPossible();
      }

      document.addEventListener("astro:page-load", initRemark42);
      initRemark42();
    })();
  </script>

  <!-- Local Graph Visualization Script -->
  <script src="/scripts/graph.js" defer></script>
</BaseLayout>

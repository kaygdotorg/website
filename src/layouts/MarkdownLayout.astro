---
import BaseLayout from "./BaseLayout.astro";
import { formatDate, getRelativeTime } from "../utils/dates";

interface Props {
  title: string;
  description?: string;
  createdDate?: Date | string;
  lastEdited?: Date | string;
  readingTime?: number;
  backlinks?: Array<{ title: string; href: string }>;
  image?: string;
}

const {
  title,
  description,
  createdDate,
  lastEdited,
  readingTime,
  backlinks = [],
  image,
} = Astro.props;

const relativeLastEdited = lastEdited ? getRelativeTime(lastEdited) : null;
const formattedLastEdited = lastEdited ? formatDate(lastEdited) : null;
const formattedCreatedDate = createdDate ? formatDate(createdDate) : null;
---

<BaseLayout title={title} description={description}>
  <div class="md-page-container">
    <!-- Unified Single Card for entire page -->
    <div class="grainy-card md-unified-card">
      <!-- Featured Image at top of card -->
      {
        image && (
          <div class="md-card-featured-image">
            <img src={image} alt={title} />
          </div>
        )
      }

      <!-- Title Section -->
      <div class="md-card-title">
        <h1>{title}</h1>
        <div class="md-card-metadata">
          {/* Reading time */}
          {
            readingTime && (
              <span title="Estimated reading time">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                  />
                </svg>
                {readingTime} min read
              </span>
            )
          }

          {/* Created date */}
          {
            formattedCreatedDate && (
              <span title="Published">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
                  />
                </svg>
                {formattedCreatedDate}
              </span>
            )
          }

          {/* Last edited - tappable to show full date */}
          {
            relativeLastEdited && (
              <span
                class="last-edited-toggle cursor-pointer"
                data-relative={`Updated ${relativeLastEdited}`}
                data-absolute={`Updated ${formattedLastEdited}`}
              >
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                  />
                </svg>
                <span class="last-edited-text">
                  Updated {relativeLastEdited}
                </span>
              </span>
            )
          }
        </div>
      </div>

      <!-- Divider -->
      <hr class="md-section-divider" />

      <!-- Table of Contents Section - Collapsible -->
      <div class="md-section md-card-collapsible md-card-toc" id="toc-card">
        <div class="md-card-header" onclick="toggleCard('toc-card')">
          <h2>Table of contents</h2>
          <svg
            class="md-card-toggle"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M19 9l-7 7-7-7"></path>
          </svg>
        </div>
        <div class="md-card-content">
          <ul id="toc-list">
            <!-- Populated by JS -->
          </ul>
        </div>
      </div>

      <!-- Divider -->
      <hr class="md-section-divider" />

      <!-- Content Section - Not collapsible -->
      <div class="md-section md-card-body" id="content-card">
        <div class="md-card-content" id="markdown-content">
          <slot />
        </div>
      </div>

      <!-- Backlinks Section - Not collapsible -->
      {
        backlinks.length > 0 && (
          <>
            <hr class="md-section-divider" />
            <div class="md-section md-card-backlinks" id="backlinks-card">
              <div class="md-backlinks-header">
                <h2>Backlinks ({backlinks.length})</h2>
              </div>
              <div class="md-card-content">
                <ul>
                  {backlinks.map((link) => (
                    <li>
                      <a href={link.href}>{link.title}</a>
                    </li>
                  ))}
                </ul>
              </div>
            </div>
          </>
        )
      }
    </div>
  </div>

  <script is:inline>
    // Toggle collapsible cards
    function toggleCard(cardId) {
      const card = document.getElementById(cardId);
      if (card) {
        card.classList.toggle("collapsed");
      }
    }

    // Wrap heading text content in spans for squiggly underline targeting
    function wrapHeadingText() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const headings = content.querySelectorAll("h2, h3, h4");
      headings.forEach((heading) => {
        // Skip if already wrapped
        if (heading.querySelector(".heading-text")) return;

        // Get the heading link if present
        const headingLink = heading.querySelector(".heading-link");

        // Create wrapper span for text content only
        const textSpan = document.createElement("span");
        textSpan.className = "heading-text";

        // Move all child nodes except .heading-link into the span
        const nodesToMove = [];
        heading.childNodes.forEach((node) => {
          if (
            node !== headingLink &&
            !node.classList?.contains("heading-link")
          ) {
            nodesToMove.push(node);
          }
        });

        nodesToMove.forEach((node) => textSpan.appendChild(node));
        heading.insertBefore(textSpan, heading.firstChild);
      });
    }

    // Generate TOC from headings
    function generateTOC() {
      const content = document.getElementById("markdown-content");
      const tocList = document.getElementById("toc-list");
      if (!content || !tocList) return;

      const headings = content.querySelectorAll("h2, h3");

      if (headings.length === 0) {
        // Hide TOC if no headings
        document.getElementById("toc-card")?.classList.add("collapsed");
        return;
      }

      headings.forEach((heading, index) => {
        // Add ID to heading if not present
        if (!heading.id) {
          heading.id = `heading-${index}`;
        }

        const li = document.createElement("li");
        li.className = `toc-level-${heading.tagName.toLowerCase() === "h2" ? "2" : "3"}`;

        const a = document.createElement("a");
        a.href = `#${heading.id}`;
        // Get text from heading-text span or fallback to textContent
        const textSpan = heading.querySelector(".heading-text");
        a.textContent = textSpan ? textSpan.textContent : heading.textContent;

        li.appendChild(a);
        tocList.appendChild(li);
      });
    }

    // Scroll Progress Button Logic
    function initScrollProgress() {
      const btn = document.getElementById("scroll-progress-btn");
      const progressFill = document.querySelector(".scroll-progress-fill");
      const downIcon = document.querySelector(
        ".scroll-progress-icon.scroll-down",
      );
      const upIcon = document.querySelector(".scroll-progress-icon.scroll-up");

      if (!btn || !progressFill || !downIcon || !upIcon) return;

      // Show the button (it's hidden by default in BaseLayout)
      btn.classList.remove("hidden");

      const circumference = 2 * Math.PI * 16; // r=16
      progressFill.style.strokeDasharray = String(circumference);
      progressFill.style.strokeDashoffset = String(circumference);

      // Track current scroll direction
      let shouldScrollDown = true;

      function updateScrollProgress() {
        const scrollTop = window.scrollY;
        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight;
        const scrollPercent = docHeight > 0 ? scrollTop / docHeight : 0;

        // Update progress ring
        const offset = circumference - scrollPercent * circumference;
        progressFill.style.strokeDashoffset = String(offset);

        // Determine direction: if in top 1/3, show down arrow; else show up arrow
        shouldScrollDown = scrollPercent < 0.33;

        if (shouldScrollDown) {
          downIcon.classList.remove("hidden");
          upIcon.classList.add("hidden");
        } else {
          downIcon.classList.add("hidden");
          upIcon.classList.remove("hidden");
        }
      }

      // Handle click
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();

        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight;

        if (shouldScrollDown) {
          // Scroll to bottom
          window.scrollTo({ top: docHeight, behavior: "smooth" });
        } else {
          // Scroll to top
          window.scrollTo({ top: 0, behavior: "smooth" });
        }
      });

      // Listen for scroll
      window.addEventListener("scroll", updateScrollProgress, {
        passive: true,
      });

      // Initial update
      updateScrollProgress();
    }

    // Last edited toggle (tap to show full date)
    function initLastEditedToggle() {
      const toggleEl = document.querySelector(".last-edited-toggle");
      if (!toggleEl) return;

      const textEl = toggleEl.querySelector(".last-edited-text");
      const relativeText = toggleEl.getAttribute("data-relative");
      const absoluteText = toggleEl.getAttribute("data-absolute");

      let showingRelative = true;

      toggleEl.addEventListener("click", () => {
        showingRelative = !showingRelative;
        if (textEl) {
          textEl.textContent = showingRelative ? relativeText : absoluteText;
        }
      });
    }

    // Initialize videos for autoplay (like Ghost)
    function initVideoAutoplay() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const videos = content.querySelectorAll("video");
      videos.forEach((video) => {
        video.muted = true;
        video.loop = true;
        video.playsInline = true;
        video.autoplay = true;
        video.play().catch(() => {
          // Autoplay blocked, ignore
        });
      });
    }

    // Initialize
    document.addEventListener("DOMContentLoaded", () => {
      wrapHeadingText();
      generateTOC();

      initScrollProgress();
      initLastEditedToggle();
      initVideoAutoplay();

      // Initialize Clipboard Links (works on both desktop and mobile)
      const content = document.getElementById("markdown-content");
      if (content) {
        function copyHeadingLink(heading) {
          if (heading && heading.id) {
            const url = `${window.location.origin}${window.location.pathname}#${heading.id}`;
            console.log("Attempting to copy:", url);

            // Add visual feedback for mobile
            heading.classList.add("tapped");
            setTimeout(() => {
              heading.classList.remove("tapped");
            }, 3000);

            // Try modern API first
            if (navigator.clipboard && window.isSecureContext) {
              navigator.clipboard
                .writeText(url)
                .then(() => {
                  console.log("Clipboard API success");
                  showToast("Link copied to clipboard!");
                })
                .catch((err) => {
                  console.error("Clipboard API failed, trying fallback:", err);
                  fallbackCopyTextToClipboard(url);
                });
            } else {
              // Fallback for non-secure contexts or missing API
              fallbackCopyTextToClipboard(url);
            }
          }
        }

        function fallbackCopyTextToClipboard(text) {
          const textArea = document.createElement("textarea");
          textArea.value = text;

          // Ensure it's not visible and doesn't scroll the page
          textArea.style.position = "fixed";
          textArea.style.left = "-9999px";
          textArea.style.top = "0";
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();

          try {
            const successful = document.execCommand("copy");
            if (successful) {
              console.log("Fallback copy success");
              showToast("Link copied to clipboard!");
            } else {
              console.error("Fallback copy failed");
            }
          } catch (err) {
            console.error("Fallback copy error:", err);
          }

          document.body.removeChild(textArea);
        }

        function handleHeadingInteraction(e) {
          console.log("Heading interaction triggered", e.type);
          // Check if clicked on heading-link icon
          const link = e.target.closest(".heading-link");
          if (link) {
            e.preventDefault();
            e.stopPropagation();
            const heading = link.closest("h1, h2, h3, h4, h5, h6");
            copyHeadingLink(heading);
            return;
          }

          // Check if clicked on heading text itself (not links or other interactive elements)
          const heading = e.target.closest("h2, h3, h4");
          if (heading && !e.target.closest("a:not(.heading-link)")) {
            e.preventDefault();
            e.stopPropagation();
            copyHeadingLink(heading);
          }
        }

        // Robust tap detection for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;

        function handleTouchStart(e) {
          const touch = e.changedTouches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          touchStartTime = Date.now();
        }

        function handleTouchEnd(e) {
          const touch = e.changedTouches[0];
          const touchEndX = touch.clientX;
          const touchEndY = touch.clientY;
          const touchEndTime = Date.now();

          const dx = Math.abs(touchEndX - touchStartX);
          const dy = Math.abs(touchEndY - touchStartY);
          const dt = touchEndTime - touchStartTime;

          // If movement is less than 10px and duration is less than 300ms, it's a tap
          if (dx < 10 && dy < 10 && dt < 300) {
            const heading = e.target.closest("h2, h3, h4");
            const link = e.target.closest(".heading-link");

            if (heading || link) {
              // Only prevent default if it's a confirmed tap on the target
              console.log("Confirmed tap on heading");
              e.preventDefault();
              handleHeadingInteraction(e);
            }
          }
        }

        content.addEventListener("touchstart", handleTouchStart, {
          passive: true,
        });
        content.addEventListener("touchend", handleTouchEnd, {
          passive: false,
        });
        // Still keep click for desktop but it won't fire if preventDefault was called on touchend
        content.addEventListener("click", handleHeadingInteraction);
      }
    });

    function showToast(message) {
      let toast = document.getElementById("toast-notification");
      if (!toast) {
        toast = document.createElement("div");
        toast.id = "toast-notification";
        toast.className = "toast-notification";
        document.body.appendChild(toast);
      }

      toast.textContent = message;
      toast.classList.add("show");

      setTimeout(() => {
        toast.classList.remove("show");
      }, 3000);
    }

    // Lightbox Logic
    function initLightbox() {
      // Create overlay if it doesn't exist
      let overlay = document.querySelector(".lightbox-overlay");
      if (!overlay) {
        overlay = document.createElement("div");
        overlay.className = "lightbox-overlay";
        overlay.innerHTML = `
          <div class="lightbox-close">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </div>
        `;
        document.body.appendChild(overlay);

        // Close logic
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay || e.target.closest(".lightbox-close")) {
            closeLightbox();
          }
        });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && overlay.classList.contains("active")) {
            closeLightbox();
          }
        });
      }

      function openLightbox(imgSrc) {
        // Remove existing image if any
        const existingImg = overlay.querySelector(".lightbox-image");
        if (existingImg) {
          existingImg.remove();
        }

        const img = document.createElement("img");
        img.src = imgSrc;
        img.className = "lightbox-image";
        overlay.appendChild(img);

        // Prevent body scroll
        document.body.style.overflow = "hidden";

        // Show overlay with slight delay for transition
        setTimeout(() => {
          overlay.classList.add("active");
        }, 10);
      }

      function closeLightbox() {
        overlay.classList.remove("active");
        document.body.style.overflow = "";
      }

      // Attach listeners to all images in the content card
      const contentImages = document.querySelectorAll(".md-unified-card img");
      contentImages.forEach((img) => {
        img.addEventListener("click", (e) => {
          e.stopPropagation(); // Prevent other clicks
          openLightbox(img.src);
        });
      });
    }

    // Make toggleCard available globally (safer assignment)
    if (typeof window.toggleCard === "undefined") {
      window.toggleCard = toggleCard;
    }

    // Run initLightbox inside DOMContentLoaded
    document.addEventListener("DOMContentLoaded", () => {
      // ... existing calls ...
      initLightbox();
    });
  </script>
</BaseLayout>

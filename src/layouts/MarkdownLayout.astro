---
import BaseLayout from "./BaseLayout.astro";
import { formatDate, getRelativeTime } from "../utils/dates";
import { getExcerpt } from "../utils/markdown";

interface Props {
  title: string;
  description?: string;
  entry?: any; // Add entry prop to extract description
  createdDate?: Date | string;
  lastEdited?: Date | string;
  readingTime?: number;
  backlinks?: Array<{ title: string; href: string }>;
  coverImage?: any;
}

const {
  title,
  description: propDescription,
  entry,
  createdDate,
  lastEdited,
  readingTime,
  backlinks = [],
  coverImage,
} = Astro.props;

// Use description from props, or extract from entry body, or fallback
const description =
  propDescription || (entry?.body ? getExcerpt(entry.body) : undefined);

// Display control logic
const displayTOC = entry?.data?.["display-table-of-contents"] !== false;
const displayDates = entry?.data?.["display-dates"] !== false;

const relativeLastEdited = lastEdited ? getRelativeTime(lastEdited) : null;
const formattedLastEdited = lastEdited ? formatDate(lastEdited) : null;
const formattedCreatedDate = createdDate ? formatDate(createdDate) : null;

// In-progress state
const displayInProgress = entry?.data?.["display-in-progress"] === true;
---

<BaseLayout title={title} description={description} displayInProgress={displayInProgress}>
  <div class="md-page-container">
    <!-- Unified Single Card for entire page -->
    <div class="frosted-card md-unified-card">
      <!-- Featured Image at top of card -->
      {
        coverImage && (
          <div class="md-card-featured-image">
            {typeof coverImage === "string" ? (
              <img src={coverImage} alt={title} loading="lazy" decoding="async" />
            ) : (
              <img
                src={coverImage.src}
                alt={title}
                loading="lazy"
                decoding="async"
                {...coverImage.attributes}
              />
            )}
          </div>
        )
      }

      <!-- Title Section -->
      <div class="md-card-title">
        <h1>{title}</h1>
        <div class="md-card-metadata">
          {/* Reading time */}
          {
            readingTime && (
              <span title="Estimated reading time">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                  />
                </svg>
                {readingTime} min read
              </span>
            )
          }

          {/* Created date */}
          {
            displayDates && formattedCreatedDate && (
              <span title="Published" data-pagefind-meta="date">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
                  />
                </svg>
                {formattedCreatedDate}
              </span>
            )
          }

          {/* Last edited - tappable to show full date */}
          {
            displayDates && relativeLastEdited && (
              <span
                class="last-edited-toggle cursor-pointer"
                data-relative={`Updated ${relativeLastEdited}`}
                data-absolute={`Updated ${formattedLastEdited}`}
              >
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                  />
                </svg>
                <span class="last-edited-text">
                  Updated {relativeLastEdited}
                </span>
              </span>
            )
          }
        </div>
      </div>

      <!-- Divider -->
      <hr class="md-section-divider" />

      <!-- Table of Contents Section - Collapsible -->
      {
        displayTOC && (
          <>
            <div class="md-section md-card-collapsible md-card-toc" id="toc-card">
              <div class="md-card-header" onclick="toggleCard('toc-card')">
                <h2>Table of contents</h2>
                <svg
                  class="md-card-toggle"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19 9l-7 7-7-7"
                  />
                </svg>
              </div>
              <div class="md-card-content">
                <ul id="toc-list">
                  <!-- Populated by JS -->
                </ul>
              </div>
            </div>
            <hr class="md-section-divider" />
          </>
        )
      }

      <!-- Content Section - Not collapsible -->
      <div class="md-section md-card-body" id="content-card">
        <div class="md-card-content" id="markdown-content">
          <slot />
        </div>
      </div>

      <!-- Backlinks Section - Not collapsible -->
      {
        backlinks.length > 0 && (
          <>
            <hr class="md-section-divider" />
            <div class="md-section md-card-backlinks" id="backlinks-card">
              <div class="md-backlinks-header">
                <h2>Backlinks ({backlinks.length})</h2>
              </div>
              <div class="md-card-content">
                <ul>
                  {backlinks.map((link) => (
                    <li>
                      <a href={link.href}>{link.title}</a>
                    </li>
                  ))}
                </ul>
              </div>
            </div>
          </>
        )
      }
    </div>
  </div>

  <script is:inline>
    // Toggle collapsible cards
    function toggleCard(cardId) {
      const card = document.getElementById(cardId);
      if (card) {
        card.classList.toggle("collapsed");
      }
    }

    // Wrap heading text content in spans for squiggly underline targeting
    function wrapHeadingText() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const headings = content.querySelectorAll("h2, h3, h4");
      headings.forEach((heading) => {
        // Skip if already wrapped
        if (heading.querySelector(".heading-text")) return;

        // Get the heading link if present
        const headingLink = heading.querySelector(".heading-link");

        // Create wrapper span for text content only
        const textSpan = document.createElement("span");
        textSpan.className = "heading-text";

        // Move all child nodes except .heading-link into the span
        const nodesToMove = [];
        heading.childNodes.forEach((node) => {
          if (
            node !== headingLink &&
            !node.classList?.contains("heading-link")
          ) {
            nodesToMove.push(node);
          }
        });

        nodesToMove.forEach((node) => textSpan.appendChild(node));
        heading.insertBefore(textSpan, heading.firstChild);
      });
    }

    // Generate TOC from headings
    function generateTOC() {
      const content = document.getElementById("markdown-content");
      const tocList = document.getElementById("toc-list");
      if (!content || !tocList) return;

      const headings = content.querySelectorAll("h2, h3");

      if (headings.length === 0) {
        // Hide TOC if no headings
        document.getElementById("toc-card")?.classList.add("collapsed");
        return;
      }

      // Clear existing TOC to prevent duplicates on re-init
      tocList.innerHTML = "";

      headings.forEach((heading, index) => {
        // Add ID to heading if not present
        if (!heading.id) {
          heading.id = `heading-${index}`;
        }

        const li = document.createElement("li");
        li.className = `toc-level-${heading.tagName.toLowerCase() === "h2" ? "2" : "3"}`;

        const a = document.createElement("a");
        a.href = `#${heading.id}`;
        // Get text from heading-text span or fallback to textContent
        const textSpan = heading.querySelector(".heading-text");
        a.textContent = textSpan ? textSpan.textContent : heading.textContent;

        li.appendChild(a);
        tocList.appendChild(li);
      });
    }

    // Scroll Progress Button Logic
    function initScrollProgress() {
      const btn = document.getElementById("scroll-progress-btn");
      const progressFill = document.querySelector(".scroll-progress-fill");
      const downIcon = document.querySelector(
        ".scroll-progress-icon.scroll-down",
      );
      const upIcon = document.querySelector(".scroll-progress-icon.scroll-up");

      if (!btn || !progressFill || !downIcon || !upIcon) return;

      // Show the button (it's hidden by default in BaseLayout)
      btn.classList.remove("hidden");

      const circumference = 2 * Math.PI * 16; // r=16
      progressFill.style.strokeDasharray = String(circumference);
      progressFill.style.strokeDashoffset = String(circumference);

      // Track current scroll direction
      let shouldScrollDown = true;

      function updateScrollProgress() {
        const scrollTop = window.scrollY;
        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight;
        const scrollPercent = docHeight > 0 ? scrollTop / docHeight : 0;

        // Update progress ring
        const offset = circumference - scrollPercent * circumference;
        progressFill.style.strokeDashoffset = String(offset);

        // Determine direction: if in top 1/3, show down arrow; else show up arrow
        shouldScrollDown = scrollPercent < 0.33;

        if (shouldScrollDown) {
          downIcon.classList.remove("hidden");
          upIcon.classList.add("hidden");
        } else {
          downIcon.classList.add("hidden");
          upIcon.classList.remove("hidden");
        }
      }

      // Handle click
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();

        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight;

        if (shouldScrollDown) {
          // Scroll to bottom
          window.scrollTo({ top: docHeight, behavior: "smooth" });
        } else {
          // Scroll to top
          window.scrollTo({ top: 0, behavior: "smooth" });
        }
      });

      // Listen for scroll
      window.addEventListener("scroll", updateScrollProgress, {
        passive: true,
      });

      // Initial update
      updateScrollProgress();
    }

    // Last edited toggle (tap to show full date)
    function initLastEditedToggle() {
      const toggleEl = document.querySelector(".last-edited-toggle");
      if (!toggleEl) return;

      const textEl = toggleEl.querySelector(".last-edited-text");
      const relativeText = toggleEl.getAttribute("data-relative");
      const absoluteText = toggleEl.getAttribute("data-absolute");

      let showingRelative = true;

      toggleEl.addEventListener("click", () => {
        showingRelative = !showingRelative;
        if (textEl) {
          textEl.textContent = showingRelative ? relativeText : absoluteText;
        }
      });
    }

    // Initialize videos for autoplay (like Ghost)
    function initVideoAutoplay() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const videos = content.querySelectorAll("video");
      videos.forEach((video) => {
        video.muted = true;
        video.loop = true;
        video.playsInline = true;
        video.autoplay = true;
        video.play().catch(() => {
          // Autoplay blocked, ignore
        });
      });
    }

    // Initialize all markdown features
    function initMarkdownFeatures() {
      wrapHeadingText();
      generateTOC();
      initCallouts();
      initScrollProgress();
      initLastEditedToggle();
      initVideoAutoplay();

      // Initialize Clipboard Links
      const content = document.getElementById("markdown-content");
      if (content && !content.dataset.clipboardInitialized) {
        initHeadingClipboard(content);
        content.dataset.clipboardInitialized = "true";
      }
    }

    // Transform Obsidian-style [!TYPE] or standard **Type:** markers into floating cards
    function initCallouts() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const blockquotes = content.querySelectorAll("blockquote");
      blockquotes.forEach((bq) => {
        // Find the first paragraph or direct text node
        const firstP = bq.querySelector("p") || bq;
        const text = firstP.innerHTML.trim();

        // 1. Match [!TYPE] or [!TYPE] Title
        // 2. Match **Type:** or **Type**
        const obsidianMatch = text.match(/^\[!(\w+)\]\s*(.*)/i);
        const boldMatch = text.match(/^<strong>(\w+):?<\/strong>\s*(.*)/i);

        const match = obsidianMatch || boldMatch;

        if (match) {
          const type = match[1].toLowerCase();
          const title = match[2];

          bq.classList.add("callout-card", `callout-${type}`);

          // Create the header with italicized type label
          const header = document.createElement("div");
          header.className = "callout-header";

          const typeLabel = document.createElement("span");
          typeLabel.className = "callout-type";
          typeLabel.innerHTML = `<em>${type}</em>`;
          header.appendChild(typeLabel);

          if (title && title.trim() !== "") {
            const titleSpan = document.createElement("span");
            titleSpan.className = "callout-title";
            titleSpan.innerHTML = title;
            header.appendChild(titleSpan);
          }

          // Prepend header
          bq.insertBefore(header, bq.firstChild);

          // Clean up the raw marker text from the first paragraph/node
          if (obsidianMatch) {
            firstP.innerHTML = firstP.innerHTML
              .replace(/^\[!(\w+)\]\s*(.*)/i, "")
              .trim();
          } else if (boldMatch) {
            firstP.innerHTML = firstP.innerHTML
              .replace(/^<strong>(\w+):?<\/strong>\s*(.*)/i, "")
              .trim();
          }

          // Remove paragraph if it's now empty
          if (firstP.innerHTML === "" && firstP !== bq) {
            firstP.remove();
          }
        }
      });
    }

    // Helper for clipboard initialization
    function initHeadingClipboard(content) {
      function copyHeadingLink(heading) {
        if (heading && heading.id) {
          const url = `${window.location.origin}${window.location.pathname}#${heading.id}`;
          heading.classList.add("tapped");
          setTimeout(() => heading.classList.remove("tapped"), 3000);

          if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard
              .writeText(url)
              .then(() => showToast("Link copied to clipboard!"))
              .catch(() => fallbackCopyTextToClipboard(url));
          } else {
            fallbackCopyTextToClipboard(url);
          }
        }
      }

      function fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-9999px";
        textArea.style.top = "0";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
          if (document.execCommand("copy"))
            showToast("Link copied to clipboard!");
        } catch (err) {}
        document.body.removeChild(textArea);
      }

      function handleHeadingInteraction(e) {
        const link = e.target.closest(".heading-link");
        if (link) {
          e.preventDefault();
          e.stopPropagation();
          copyHeadingLink(link.closest("h1, h2, h3, h4, h5, h6"));
          return;
        }
        const heading = e.target.closest("h2, h3, h4");
        if (heading && !e.target.closest("a:not(.heading-link)")) {
          e.preventDefault();
          e.stopPropagation();
          copyHeadingLink(heading);
        }
      }

      let touchStartX = 0,
        touchStartY = 0,
        touchStartTime = 0;
      content.addEventListener(
        "touchstart",
        (e) => {
          const touch = e.changedTouches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          touchStartTime = Date.now();
        },
        { passive: true },
      );

      content.addEventListener(
        "touchend",
        (e) => {
          const touch = e.changedTouches[0];
          const dx = Math.abs(touch.clientX - touchStartX);
          const dy = Math.abs(touch.clientY - touchStartY);
          const dt = Date.now() - touchStartTime;
          if (dx < 10 && dy < 10 && dt < 300) {
            const heading = e.target.closest("h2, h3, h4");
            const link = e.target.closest(".heading-link");
            if (heading || link) {
              e.preventDefault();
              handleHeadingInteraction(e);
            }
          }
        },
        { passive: false },
      );

      content.addEventListener("click", handleHeadingInteraction);
    }

    // Initialize on load and on page transitions
    document.addEventListener("DOMContentLoaded", initMarkdownFeatures);
    document.addEventListener("astro:page-load", initMarkdownFeatures);

    function showToast(message) {
      let toast = document.getElementById("toast-notification");
      if (!toast) {
        toast = document.createElement("div");
        toast.id = "toast-notification";
        toast.className = "toast-notification";
        document.body.appendChild(toast);
      }

      toast.textContent = message;
      toast.classList.add("show");

      setTimeout(() => {
        toast.classList.remove("show");
      }, 3000);
    }

    // Make toggleCard available globally (safer assignment)
    if (typeof window.toggleCard === "undefined") {
      window.toggleCard = toggleCard;
    }
  </script>
</BaseLayout>

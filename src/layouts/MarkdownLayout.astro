---
import BaseLayout from "./BaseLayout.astro";
import { Image } from "astro:assets";
import { formatDate, getRelativeTime } from "../utils/dates";
import { getExcerpt } from "../utils/markdown";

interface Props {
  title: string;
  description?: string;
  entry?: any; // Add entry prop to extract description
  createdDate?: Date | string;
  lastEdited?: Date | string;
  readingTime?: number;
  backlinks?: Array<{ title: string; href: string }>;
  coverImage?: any;
}

const {
  title,
  description: propDescription,
  entry,
  createdDate,
  lastEdited,
  readingTime,
  backlinks = [],
  coverImage,
} = Astro.props;

// Use description from props, or extract from entry body, or fallback
const description =
  propDescription || (entry?.body ? getExcerpt(entry.body) : undefined);

// Display control logic
const displayTOC = entry?.data?.["display-table-of-contents"] !== false;
const displayDates = entry?.data?.["display-dates"] !== false;
const displayComments = entry?.data?.["display-comments"] !== false;

const relativeLastEdited = lastEdited ? getRelativeTime(lastEdited) : null;
const formattedLastEdited = lastEdited ? formatDate(lastEdited) : null;
const formattedCreatedDate = createdDate ? formatDate(createdDate) : null;

// In-progress state
const displayInProgress = entry?.data?.["display-in-progress"] === true;

// Generate Article JSON-LD schema for blog posts (only if we have a date)
const articleSchema = createdDate ? {
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": title,
  "description": description || "",
  "datePublished": new Date(createdDate).toISOString(),
  ...(lastEdited && { "dateModified": new Date(lastEdited).toISOString() }),
  ...(coverImage && { 
    "image": typeof coverImage === "string" 
      ? `${Astro.url.origin}${coverImage}` 
      : `${Astro.url.origin}${coverImage.src}` 
  }),
  "author": {
    "@type": "Person",
    "@id": `${Astro.url.origin}/#person`,
    "name": "K Gopal Krishna"
  },
  "publisher": {
    "@type": "Person",
    "@id": `${Astro.url.origin}/#person`,
    "name": "K Gopal Krishna"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": Astro.url.href
  }
} : null;

// Construct GitHub history URL using the entry's relative file path
// This allows users to view the commit history for the specific markdown file
const githubUrl = entry?.filePath 
  ? `https://github.com/kaygdotorg/website/commits/main/${entry.filePath}`
  : null;

---

<BaseLayout title={title} description={description} displayInProgress={displayInProgress} ogImage={typeof coverImage === "string" ? coverImage : coverImage?.src}>
  {/* Article JSON-LD Schema - only rendered for date-based content like blog posts */}
  {articleSchema && (
    <script type="application/ld+json" set:html={JSON.stringify(articleSchema)} />
  )}

  <div class="md-page-container">
    <!-- Unified Single Card for entire page -->
    <div class="frosted-card md-unified-card">
      <!-- Featured Image at top of card -->
      <!-- GIFs use plain <img> to preserve animation; other formats use <Image /> for optimization -->
      {
        coverImage && (
          <div class="md-card-featured-image">
            {typeof coverImage === "string" ? (
              <img src={coverImage} alt={title} loading="lazy" decoding="async" />
            ) : coverImage.format === "gif" ? (
              <img
                src={coverImage.src}
                alt={title}
                loading="lazy"
                decoding="async"
              />
            ) : (
              <Image
                src={coverImage}
                alt={title}
                loading="lazy"
                decoding="async"
              />
            )}
          </div>
        )
      }

      <!-- Title Section -->
      <div class="md-card-title">
        <h1>{title}</h1>
        <div class="md-card-metadata">
          {/* Reading time */}
          {
            readingTime && (
              <span title="Estimated reading time">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                  />
                </svg>
                {readingTime} min read
              </span>
            )
          }

          {/* Created date */}
          {
            displayDates && formattedCreatedDate && (
              <>
                {readingTime && <span class="opacity-20">•</span>}
                <span title="Published" data-pagefind-meta="date">
                  <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
                    />
                  </svg>
                  {formattedCreatedDate}
                </span>
              </>
            )
          }

          {/* Last edited - tappable to show full date */}
          {
            displayDates && relativeLastEdited && (
              <>
                {(readingTime || (displayDates && formattedCreatedDate)) && <span class="opacity-20">•</span>}
                <div class="flex items-center gap-3">
                  <span
                    class="last-edited-toggle cursor-pointer inline-flex items-center gap-1.5 hover:text-base-content transition-colors"
                    data-relative={`Updated ${relativeLastEdited}`}
                    data-absolute={`Updated ${formattedLastEdited}`}
                  >
                    <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-4 h-4">
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                      />
                    </svg>
                    <span class="last-edited-text">
                      Updated {relativeLastEdited}
                    </span>
                  </span>
                  
                  {githubUrl && (
                    <>
                      <span class="opacity-20">•</span>
                      <a 
                        href={githubUrl}
                        target="_blank"
                        rel="noopener noreferrer"
                        class="inline-flex items-center gap-1.5 hover:text-base-content transition-colors opacity-100"
                        title="View history on GitHub"
                      >
                        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-4 h-4">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        History
                      </a>
                    </>
                  )}
                </div>
              </>
            )
          }
        </div>
      </div>

      <!-- Divider -->
      <hr class="md-section-divider" />

      <!-- Table of Contents Section - Collapsible -->
      {
        displayTOC && (
          <>
            <div class="md-section md-card-collapsible md-card-toc" id="toc-card">
              <div class="md-card-header" onclick="toggleCard('toc-card')">
                <h2>Table of contents</h2>
                <svg
                  class="md-card-toggle"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19 9l-7 7-7-7"
                  />
                </svg>
              </div>
              <div class="md-card-content">
                <ul id="toc-list">
                  <!-- Populated by JS -->
                </ul>
              </div>
            </div>
            <hr class="md-section-divider" />
          </>
        )
      }

      <!-- Content Section - Not collapsible -->
      <div class="md-section md-card-body" id="content-card">
        <div class="md-card-content" id="markdown-content">
          <slot />
        </div>
        
        {/* Tags Section at bottom of content */}
        {entry?.data?.tags && entry.data.tags.length > 0 && (
          <div class="md-tags-footer mt-12 pt-8 border-t border-base-content/5">
            <div class="md-card-content">
              <div class="flex items-center gap-3 text-sm text-base-content/40">
                <span>Filed under</span>
                <div class="flex flex-wrap gap-2">
                  {entry.data.tags.map((tag: string) => (
                    <span class="px-2.5 py-0.5 rounded-lg bg-base-content/5 text-base-content/50 hover:text-base-content hover:bg-base-content/10 transition-all cursor-default">
                      #{tag}
                    </span>
                  ))}
                </div>
              </div>
            </div>
          </div>
        )}
      </div>

      <!-- Backlinks Section - Not collapsible -->
      {
        backlinks.length > 0 && (
          <>
            <hr class="md-section-divider" />
            <div class="md-section md-card-backlinks" id="backlinks-card">
              <div class="md-backlinks-header">
                <h2>Backlinks ({backlinks.length})</h2>
              </div>
              <div class="md-card-content">
                <ul>
                  {backlinks.map((link) => (
                    <li>
                      <a href={link.href}>{link.title}</a>
                    </li>
                  ))}
                </ul>
              </div>
            </div>
          </>
        )
      }

    </div>

    <!-- Comments Section - Separate Card -->
    {
      displayComments && (
        <div class="frosted-card md-comments-card">
          <div class="md-comments-header">
            <h2>Comments</h2>
          </div>
          <div class="md-card-content">
            <div id="remark42"></div>
          </div>
        </div>
      )
    }
  </div>

  <script is:inline>
    // Toggle collapsible cards
    function toggleCard(cardId) {
      const card = document.getElementById(cardId);
      if (card) {
        card.classList.toggle("collapsed");
      }
    }

    // Wrap heading text content in spans for squiggly underline targeting
    function wrapHeadingText() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const headings = content.querySelectorAll("h2, h3, h4");
      headings.forEach((heading) => {
        // Skip if already wrapped
        if (heading.querySelector(".heading-text")) return;

        // Get the heading link if present
        const headingLink = heading.querySelector(".heading-link");

        // Create wrapper span for text content only
        const textSpan = document.createElement("span");
        textSpan.className = "heading-text";

        // Move all child nodes except .heading-link into the span
        const nodesToMove = [];
        heading.childNodes.forEach((node) => {
          if (
            node !== headingLink &&
            !node.classList?.contains("heading-link")
          ) {
            nodesToMove.push(node);
          }
        });

        nodesToMove.forEach((node) => textSpan.appendChild(node));
        heading.insertBefore(textSpan, heading.firstChild);
      });
    }

    // Generate TOC from headings
    function generateTOC() {
      const content = document.getElementById("markdown-content");
      const tocList = document.getElementById("toc-list");
      if (!content || !tocList) return;

      const headings = content.querySelectorAll("h2, h3");

      if (headings.length === 0) {
        // Hide TOC if no headings
        document.getElementById("toc-card")?.classList.add("collapsed");
        return;
      }

      // Clear existing TOC to prevent duplicates on re-init
      tocList.innerHTML = "";

      headings.forEach((heading, index) => {
        // Add ID to heading if not present
        if (!heading.id) {
          heading.id = `heading-${index}`;
        }

        const li = document.createElement("li");
        li.className = `toc-level-${heading.tagName.toLowerCase() === "h2" ? "2" : "3"}`;

        const a = document.createElement("a");
        a.href = `#${heading.id}`;
        // Get text from heading-text span or fallback to textContent
        const textSpan = heading.querySelector(".heading-text");
        a.textContent = textSpan ? textSpan.textContent : heading.textContent;

        li.appendChild(a);
        tocList.appendChild(li);
      });
    }

    // Scroll Progress Button Logic
    function initScrollProgress() {
      const btn = document.getElementById("scroll-progress-btn");
      const progressFill = document.querySelector(".scroll-progress-fill");
      const downIcon = document.querySelector(
        ".scroll-progress-icon.scroll-down",
      );
      const upIcon = document.querySelector(".scroll-progress-icon.scroll-up");

      if (!btn || !progressFill || !downIcon || !upIcon) return;

      // Show the button (it's hidden by default in BaseLayout)
      btn.classList.remove("hidden");

      const circumference = 2 * Math.PI * 16; // r=16
      progressFill.style.strokeDasharray = String(circumference);
      progressFill.style.strokeDashoffset = String(circumference);

      // Track current scroll direction
      let shouldScrollDown = true;

      function updateScrollProgress() {
        const scrollTop = window.scrollY;
        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight;
        const scrollPercent = docHeight > 0 ? scrollTop / docHeight : 0;

        // Update progress ring
        const offset = circumference - scrollPercent * circumference;
        progressFill.style.strokeDashoffset = String(offset);

        // Determine direction: if in top 1/3, show down arrow; else show up arrow
        shouldScrollDown = scrollPercent < 0.33;

        if (shouldScrollDown) {
          downIcon.classList.remove("hidden");
          upIcon.classList.add("hidden");
        } else {
          downIcon.classList.add("hidden");
          upIcon.classList.remove("hidden");
        }
      }

      // Handle click
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();

        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight;

        if (shouldScrollDown) {
          // Scroll to bottom
          window.scrollTo({ top: docHeight, behavior: "smooth" });
        } else {
          // Scroll to top
          window.scrollTo({ top: 0, behavior: "smooth" });
        }
      });

      // Listen for scroll
      window.addEventListener("scroll", updateScrollProgress, {
        passive: true,
      });

      // Initial update
      updateScrollProgress();
    }

    // Last edited toggle (tap to show full date)
    function initLastEditedToggle() {
      const toggleEl = document.querySelector(".last-edited-toggle");
      if (!toggleEl) return;

      const textEl = toggleEl.querySelector(".last-edited-text");
      const relativeText = toggleEl.getAttribute("data-relative");
      const absoluteText = toggleEl.getAttribute("data-absolute");

      let showingRelative = true;

      toggleEl.addEventListener("click", () => {
        showingRelative = !showingRelative;
        if (textEl) {
          textEl.textContent = showingRelative ? relativeText : absoluteText;
        }
      });
    }

    // Initialize videos for autoplay (like Ghost)
    function initVideoAutoplay() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const videos = content.querySelectorAll("video");
      videos.forEach((video) => {
        video.muted = true;
        video.loop = true;
        video.playsInline = true;
        video.autoplay = true;
        video.play().catch(() => {
          // Autoplay blocked, ignore
        });
      });
    }

    // Initialize all markdown features
    function initMarkdownFeatures() {
      wrapHeadingText();
      generateTOC();
      initCallouts();
      initScrollProgress();
      initLastEditedToggle();
      initVideoAutoplay();

      // Initialize Clipboard Links
      const content = document.getElementById("markdown-content");
      if (content && !content.dataset.clipboardInitialized) {
        initHeadingClipboard(content);
        content.dataset.clipboardInitialized = "true";
      }
    }

    // Transform Obsidian-style [!TYPE] or standard **Type:** markers into floating cards
    function initCallouts() {
      const content = document.getElementById("markdown-content");
      if (!content) return;

      const blockquotes = content.querySelectorAll("blockquote");
      blockquotes.forEach((bq) => {
        // Find the first paragraph or direct text node
        const firstP = bq.querySelector("p") || bq;
        const text = firstP.innerHTML.trim();

        // 1. Match [!TYPE] or [!TYPE] Title
        // 2. Match **Type:** or **Type**
        const obsidianMatch = text.match(/^\[!(\w+)\]\s*(.*)/i);
        const boldMatch = text.match(/^<strong>(\w+):?<\/strong>\s*(.*)/i);

        const match = obsidianMatch || boldMatch;

        if (match) {
          const type = match[1].toLowerCase();
          const title = match[2];

          bq.classList.add("callout-card", `callout-${type}`);

          // Create the header with italicized type label
          const header = document.createElement("div");
          header.className = "callout-header";

          const typeLabel = document.createElement("span");
          typeLabel.className = "callout-type";
          typeLabel.innerHTML = `<em>${type}</em>`;
          header.appendChild(typeLabel);

          if (title && title.trim() !== "") {
            const titleSpan = document.createElement("span");
            titleSpan.className = "callout-title";
            titleSpan.innerHTML = title;
            header.appendChild(titleSpan);
          }

          // Prepend header
          bq.insertBefore(header, bq.firstChild);

          // Clean up the raw marker text from the first paragraph/node
          if (obsidianMatch) {
            firstP.innerHTML = firstP.innerHTML
              .replace(/^\[!(\w+)\]\s*(.*)/i, "")
              .trim();
          } else if (boldMatch) {
            firstP.innerHTML = firstP.innerHTML
              .replace(/^<strong>(\w+):?<\/strong>\s*(.*)/i, "")
              .trim();
          }

          // Remove paragraph if it's now empty
          if (firstP.innerHTML === "" && firstP !== bq) {
            firstP.remove();
          }
        }
      });
    }

    // Helper for clipboard initialization
    function initHeadingClipboard(content) {
      function copyHeadingLink(heading) {
        if (heading && heading.id) {
          const url = `${window.location.origin}${window.location.pathname}#${heading.id}`;
          heading.classList.add("tapped");
          setTimeout(() => heading.classList.remove("tapped"), 3000);

          if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard
              .writeText(url)
              .then(() => showToast("Link copied to clipboard!"))
              .catch(() => fallbackCopyTextToClipboard(url));
          } else {
            fallbackCopyTextToClipboard(url);
          }
        }
      }

      function fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-9999px";
        textArea.style.top = "0";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
          if (document.execCommand("copy"))
            showToast("Link copied to clipboard!");
        } catch (err) {}
        document.body.removeChild(textArea);
      }

      function handleHeadingInteraction(e) {
        const link = e.target.closest(".heading-link");
        if (link) {
          e.preventDefault();
          e.stopPropagation();
          copyHeadingLink(link.closest("h1, h2, h3, h4, h5, h6"));
          return;
        }
        const heading = e.target.closest("h2, h3, h4");
        if (heading && !e.target.closest("a:not(.heading-link)")) {
          e.preventDefault();
          e.stopPropagation();
          copyHeadingLink(heading);
        }
      }

      let touchStartX = 0,
        touchStartY = 0,
        touchStartTime = 0;
      content.addEventListener(
        "touchstart",
        (e) => {
          const touch = e.changedTouches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          touchStartTime = Date.now();
        },
        { passive: true },
      );

      content.addEventListener(
        "touchend",
        (e) => {
          const touch = e.changedTouches[0];
          const dx = Math.abs(touch.clientX - touchStartX);
          const dy = Math.abs(touch.clientY - touchStartY);
          const dt = Date.now() - touchStartTime;
          if (dx < 10 && dy < 10 && dt < 300) {
            const heading = e.target.closest("h2, h3, h4");
            const link = e.target.closest(".heading-link");
            if (heading || link) {
              e.preventDefault();
              handleHeadingInteraction(e);
            }
          }
        },
        { passive: false },
      );

      content.addEventListener("click", handleHeadingInteraction);
    }

    // Initialize on load and on page transitions
    document.addEventListener("DOMContentLoaded", initMarkdownFeatures);
    document.addEventListener("astro:page-load", initMarkdownFeatures);

    function showToast(message) {
      let toast = document.getElementById("toast-notification");
      if (!toast) {
        toast = document.createElement("div");
        toast.id = "toast-notification";
        toast.className = "toast-notification";
        document.body.appendChild(toast);
      }

      toast.textContent = message;
      toast.classList.add("show");

      setTimeout(() => {
        toast.classList.remove("show");
      }, 3000);
    }

    // Make toggleCard available globally (safer assignment)
    if (typeof window.toggleCard === "undefined") {
      window.toggleCard = toggleCard;
    }
  </script>

  <!-- Remark42 Comments Scripts (only loaded if comments container exists) -->
  <script is:inline>
    (function () {
      const STATE_KEY = "__remark42State";
      const state = (window[STATE_KEY] = window[STATE_KEY] || {
        scriptsLoaded: false,
        themeObserver: null,
      });

      function currentTheme() {
        return document.documentElement.getAttribute("data-theme") === "light"
          ? "light"
          : "dark";
      }

      function setRemarkConfig() {
        window.remark_config = {
          host: "https://remark42.kayg.org",
          site_id: "kayg.org",
          components: ["embed"],
          max_shown_comments: 15,
          theme: currentTheme(),
          page_title: document.title,
        };
      }

      function loadScriptsOnce() {
        if (state.scriptsLoaded) return;
        state.scriptsLoaded = true;

        // Load remark42 embed script (official loader, minified)
        !(function (e, n) {
          for (var o = 0; o < e.length; o++) {
            var r = n.createElement("script"),
              c = ".js",
              d = n.head || n.body;
            ("noModule" in r
              ? ((r.type = "module"), (c = ".mjs"))
              : (r.async = !0),
              (r.defer = !0),
              (r.src = remark_config.host + "/web/" + e[o] + c),
              d.appendChild(r));
          }
        })(remark_config.components || ["embed"], document);
      }

      function ensureThemeSync() {
        if (state.themeObserver) return;
        state.themeObserver = new MutationObserver((mutations) => {
          for (const mutation of mutations) {
            if (mutation.attributeName === "data-theme" && window.REMARK42) {
              window.REMARK42.changeTheme(currentTheme());
            }
          }
        });
        state.themeObserver.observe(document.documentElement, { attributes: true });
      }

      function mountIfPossible() {
        const container = document.getElementById("remark42");
        if (!container) return;

        // View Transitions can swap the container while keeping scripts.
        // If Remark42 is already loaded, remount into the new container.
        if (window.REMARK42 && typeof window.REMARK42.createInstance === "function") {
          window.REMARK42.createInstance(window.remark_config);
        }
      }

      function initRemark42() {
        if (!document.getElementById("remark42")) return;
        setRemarkConfig();
        loadScriptsOnce();
        ensureThemeSync();
        mountIfPossible();
      }

      document.addEventListener("astro:page-load", initRemark42);
      initRemark42();
    })();
  </script>
</BaseLayout>

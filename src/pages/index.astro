---
import BaseLayout from "../layouts/BaseLayout.astro";
import Timeline from "../components/Timeline.astro";
import { getCollection } from "astro:content";
import { formatDateWithComma } from "../utils/dates";

// Use getCollection and filter for index.md - more reliable than getEntry
const allHomeEntries = await getCollection("home");
const homeEntry = allHomeEntries.find((e) => e.id === "index.md");

if (!homeEntry) {
  throw new Error("Could not find index.md in src/content/home/");
}

const { Content } = await homeEntry.render();

// Fetch entries from now, uses, and blog collections (exclude index.md landing pages)
const nowEntries = await getCollection("now", ({ id }) => id !== "index.md");
const usesEntries = await getCollection("uses", ({ id }) => id !== "index.md");
const blogEntries = await getCollection(
  "blog",
  ({ id, data }) => id !== "index.md" && !data.draft,
);
const talksEntries = await getCollection(
  "talks",
  ({ id }) => id !== "index.md",
);
const notesEntries = await getCollection(
  "notes",
  ({ id, data }) => id !== "index.md" && !data.draft,
);

// Sort to get latest entries
const latestNow = nowEntries.sort(
  (a, b) => b.data.date.getTime() - a.data.date.getTime(),
)[0];
const latestUses = usesEntries.sort(
  (a, b) => b.data.date.getTime() - a.data.date.getTime(),
)[0];

// Get latest entries for bento cards
const latestBlog = blogEntries.sort(
  (a, b) => b.data.date.valueOf() - a.data.date.valueOf(),
)[0];
const latestTalk = talksEntries.sort(
  (a, b) => b.data.date.getTime() - a.data.date.getTime(),
)[0];
const latestNote = notesEntries.sort(
  (a, b) => b.data.date.getTime() - a.data.date.getTime(),
)[0];

// Create a map of slug -> lastUpdated date
const pageLastUpdated = new Map<string, Date>();
if (latestNow) {
  pageLastUpdated.set("/now", latestNow.data.date);
}
if (latestUses) {
  pageLastUpdated.set("/uses", latestUses.data.date);
}
if (latestTalk) {
  pageLastUpdated.set("/talks", latestTalk.data.date);
}
if (latestNote) {
  pageLastUpdated.set("/notes", latestNote.data.date);
}

// Extract all the data from frontmatter
const {
  name,
  tagline,
  profileImage,
  email,
  cardPhotos: rawCardPhotos,
  bentoCards: rawBentoCards,
  quote,
  workExperience,
  resumeUrl,
} = homeEntry.data;

// Enhance bento cards with actual latest content where applicable
const bentoCards = rawBentoCards?.map((card: any) => {
  if (card.id === "blog" && latestBlog) {
    return {
      ...card,
      title: latestBlog.data.title,
      summary: latestBlog.data.description || card.summary,
    };
  }
  if (card.id === "talks" && latestTalk) {
    return {
      ...card,
      title: latestTalk.data.title,
    };
  }
  if (card.id === "notes" && latestNote) {
    return {
      ...card,
      summary: `Latest: ${latestNote.data.title}`,
    };
  }
  if (card.id === "now" && latestNow) {
    return {
      ...card,
      summary: `Focused on: ${latestNow.data.title}`,
    };
  }
  return card;
});

// Enhance cardPhotos with dynamic dates from page metadata
const cardPhotos = rawCardPhotos?.map((card: any) => {
  const pageDate = pageLastUpdated.get(card.href);
  return {
    ...card,
    date: pageDate ? formatDateWithComma(pageDate) : card.date || "Unknown",
  };
});
---

<BaseLayout
  title="Home"
  description="Personal website and digital garden"
  hideNavInitially={true}
>
  <main class="homepage">
    <!-- Hero Section -->
    <section class="hero-section" id="hero-section">
      <div class="frosted-card-homepage hero-card hero-glow">
        <div class="hero-content">
          <!-- Profile Picture - handles both optimized images (ImageMetadata) and URL strings -->
          {
            profileImage && (
              <div class="hero-profile">
                <img
                  src={typeof profileImage === 'string' ? profileImage : profileImage.src}
                  alt={`${name || "Profile"} photo`}
                  class="hero-profile-img"
                  fetchpriority="high"
                  decoding="async"
                />
              </div>
            )
          }

          <!-- Name -->
          <h1 class="hero-name">{name}</h1>

          <!-- Tagline -->
          <p class="hero-tagline">
            {tagline}
          </p>
        </div>

        <!-- Card Hand (Polaroids) -->
        {
          cardPhotos && cardPhotos.length > 0 && (
            <div class="hero-cards-section" id="hero-photo-section">
              <div class="card-hand" id="card-hand">
                <div class="card-hand-inner" id="card-hand-inner">
                  {cardPhotos.map((item: any, index: number) => (
                    <a
                      href={item.href}
                      class="card-in-hand"
                      data-index={index}
                      data-position={index}
                    >
                      <div class="card-in-hand-image">
                        <img
                          src={typeof item.src === 'string' ? item.src : item.src.src}
                          alt={item.label}
                          draggable="false"
                          loading="lazy"
                          decoding="async"
                        />
                      </div>
                      <div class="card-in-hand-label">
                        <div class="card-in-hand-slug">{item.href}</div>
                        <div class="card-in-hand-date">
                          {item.date || "Dec 2024"}
                        </div>
                      </div>
                    </a>
                  ))}
                </div>
              </div>
              <p class="hero-cards-hint">
                swipe to shuffle · tap to navigate · scroll to explore
              </p>
            </div>
          )
        }
      </div>
    </section>

    <!-- Bento Grid Section - Asymmetric grid inspired by mymind.com -->
    <!-- The grid is wrapped in a container card for visual grouping -->
    <section class="bento-section">
      <div class="frosted-card-homepage bento-wrapper">
        <!-- Section header -->
        <div class="bento-header">
          <span class="bento-header-label">Explore</span>
          <h2 class="bento-header-title">A little bit about me</h2>
        </div>

        <div class="bento-grid">
          {
            bentoCards?.map((card: any) => (
              <a href={card.href} class={`bento-card bento-${card.id}`}>
                {/* 1. Image / Visual (Top) */}
                <div class="bento-visual-container">
                  {card.id === "photography" ? (
                    /* Special stack for photography */
                    <div class="photo-grid-feature">
                      <div class="photo-stack">
                        {cardPhotos?.slice(0, 4).map((photo: any) => (
                          <div class="photo-stack-item">
                            <img src={typeof photo.src === 'string' ? photo.src : photo.src.src} alt="Capture" loading="lazy" decoding="async" />
                          </div>
                        ))}
                      </div>
                    </div>
                  ) : card.image === "obsidian-graph" ? (
                    <div class="obsidian-graph-container" id="obsidian-graph">
                      <canvas id="graph-canvas" />
                    </div>
                  ) : (
                    <div class="bento-image-wrapper">
                      {/* Handle both optimized images (ImageMetadata with .src) and URL strings */}
                      <img src={typeof card.image === 'string' ? card.image : card.image.src} alt={card.title} loading="lazy" decoding="async" />
                    </div>
                  )}
                </div>

                {/* 2. Category & Info (Middle) */}
                <div class="bento-content-container">
                  <div class="bento-meta">
                    <span class="bento-category">
                      {card.id === "notes" ? "Notes" : card.category}
                      {card.id === "now" && <span class="pulse-dot" />}
                    </span>
                    {card.id === "notes" && (
                      <span class="bento-title-aside">{card.title}</span>
                    )}
                  </div>

                  {card.id !== "notes" && (
                    <h3 class="bento-card-title">{card.title}</h3>
                  )}

                  {/* 3. Excerpt (Bottom) */}
                  <p class="bento-excerpt">{card.summary}</p>
                </div>
              </a>
            ))
          }
        </div>
      </div>
    </section>

    <!-- Work Experience Section -->
    <Timeline experience={workExperience} resumeUrl={resumeUrl} />
  </main>

  <!-- Card Hand Swipe Script -->
  <script>
    // =========================================================================
    // HOMEPAGE INITIALIZATION GUARDS
    // =========================================================================
    //
    // These guards prevent event listeners and observers from stacking up
    // when navigating to/from the homepage via View Transitions.
    //
    // PROBLEM: With Astro View Transitions, the document object persists
    // across navigations, but this script runs fresh each time you visit
    // the homepage. Without guards:
    // - First visit: adds listener #1
    // - Navigate away and back: adds listener #2 (both now fire!)
    // - Each visit adds more duplicate listeners
    //
    // SOLUTION: Use window-level flags and cleanup functions to ensure
    // only one instance of each listener/observer exists at a time.
    //
    // =========================================================================

    // Cleanup interface stored on window for cross-navigation persistence
    interface HomepageCleanup {
      resizeListener?: () => void;
      graphObserver?: IntersectionObserver;
      navObserver?: IntersectionObserver;
      pageLoadListener?: () => void;
    }

    // Initialize or retrieve the cleanup registry
    const cleanup: HomepageCleanup =
      (window as any).__homepageCleanup || ((window as any).__homepageCleanup = {});

    const cardHand = document.getElementById("card-hand");
    const cards = document.querySelectorAll(
      ".card-in-hand",
    ) as NodeListOf<HTMLElement>;

    if (cardHand && cards.length > 0) {
      const numCards = cards.length;
      let currentOffset = 0;
      let isDragging = false;
      let hasMoved = false;
      let startX = 0;
      let currentX = 0;
      let dragThreshold = 50;
      let tapThreshold = 10;

      function updateCardPositions() {
        cards.forEach((card, index) => {
          let posIndex = (index - currentOffset + numCards) % numCards;
          card.setAttribute("data-position", posIndex.toString());
        });
      }

      function handleCardStart(e: MouseEvent | TouchEvent) {
        isDragging = true;
        hasMoved = false;
        startX = "touches" in e ? e.touches[0].clientX : e.clientX;
        currentX = startX;
        e.stopPropagation();
      }

      function handleCardMove(e: MouseEvent | TouchEvent) {
        if (!isDragging) return;
        currentX = "touches" in e ? e.touches[0].clientX : e.clientX;

        if (Math.abs(currentX - startX) > tapThreshold) {
          hasMoved = true;
        }
      }

      function handleCardEnd() {
        if (!isDragging) return;
        isDragging = false;

        const deltaX = currentX - startX;

        if (Math.abs(deltaX) > dragThreshold) {
          if (deltaX < 0) {
            currentOffset = (currentOffset + 1) % numCards;
          } else {
            currentOffset = (currentOffset - 1 + numCards) % numCards;
          }
          updateCardPositions();
        }
      }

      cards.forEach((card) => {
        card.addEventListener("click", (e) => {
          if (hasMoved) {
            e.preventDefault();
            e.stopPropagation();
          }
          hasMoved = false;
        });

        card.addEventListener("mousedown", handleCardStart);
        card.addEventListener("touchstart", handleCardStart, {
          passive: false,
        });
      });

      cardHand.addEventListener("mousedown", handleCardStart);
      cardHand.addEventListener("touchstart", handleCardStart, {
        passive: false,
      });

      document.addEventListener("mousemove", handleCardMove);
      document.addEventListener("mouseup", handleCardEnd);
      document.addEventListener("touchmove", handleCardMove, { passive: true });
      document.addEventListener("touchend", handleCardEnd);

      // Horizontal scroll/wheel to shuffle cards
      let wheelTimeout: ReturnType<typeof setTimeout> | null = null;
      let accumulatedDelta = 0;
      const wheelThreshold = 50;

      cardHand.addEventListener(
        "wheel",
        (e: WheelEvent) => {
          const delta =
            Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;

          e.stopPropagation();
          accumulatedDelta += delta;

          if (wheelTimeout) clearTimeout(wheelTimeout);

          if (Math.abs(accumulatedDelta) > wheelThreshold) {
            if (accumulatedDelta > 0) {
              currentOffset = (currentOffset + 1) % numCards;
            } else {
              currentOffset = (currentOffset - 1 + numCards) % numCards;
            }
            updateCardPositions();
            accumulatedDelta = 0;
          }

          wheelTimeout = setTimeout(() => {
            accumulatedDelta = 0;
          }, 150);
        },
        { passive: true },
      );

      updateCardPositions();
    }

    /**
     * =========================================================================
     * OBSIDIAN GRAPH ANIMATION
     * =========================================================================
     *
     * Renders an animated node graph visualization simulating an Obsidian-style
     * knowledge graph. Uses HTML5 Canvas for performant rendering.
     *
     * VISUAL BEHAVIOR:
     * - 25 nodes (small circles) float around the canvas
     * - Nodes that are close together are connected by semi-transparent lines
     * - Nodes bounce off the edges to stay within bounds
     * - The animation runs at 60fps using requestAnimationFrame
     *
     * -------------------------------------------------------------------------
     * PERFORMANCE OPTIMIZATION: IntersectionObserver
     * -------------------------------------------------------------------------
     *
     * PROBLEM: Without optimization, requestAnimationFrame runs continuously
     * at ~60fps even when the user has scrolled past the graph and it's not
     * visible. This wastes CPU/GPU cycles and drains battery on mobile.
     *
     * SOLUTION: Use IntersectionObserver to detect when the canvas container
     * enters or leaves the viewport:
     *
     *   1. When canvas becomes VISIBLE (isIntersecting: true):
     *      - Set isAnimating = true
     *      - Call draw() to start the animation loop
     *
     *   2. When canvas becomes HIDDEN (isIntersecting: false):
     *      - Set isAnimating = false
     *      - The next draw() call will see isAnimating = false and NOT
     *        schedule another frame, gracefully stopping the loop
     *
     * This pattern ensures:
     * - Animation runs smoothly when visible
     * - Zero CPU usage when scrolled away
     * - No "jump" or visual artifact when returning (nodes continue from
     *   their last position)
     *
     * -------------------------------------------------------------------------
     * FLICKER PREVENTION
     * -------------------------------------------------------------------------
     *
     * The animation starts paused (isAnimating = false) and only begins when
     * the observer detects the canvas is visible. This prevents any potential
     * race conditions between initialization and visibility detection.
     *
     * =========================================================================
     */
    function initObsidianGraph() {
      // -----------------------------------------------------------------------
      // CANVAS SETUP
      // -----------------------------------------------------------------------
      const canvas = document.getElementById(
        "graph-canvas",
      ) as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      // -----------------------------------------------------------------------
      // ANIMATION STATE
      // -----------------------------------------------------------------------

      /**
       * Controls whether the animation loop continues running.
       * - true: animation is running (canvas is visible)
       * - false: animation is paused (canvas is off-screen)
       *
       * The draw() function checks this flag and only schedules the next
       * frame if it's true. This is the key mechanism for pausing.
       */
      let isAnimating = false;

      // -----------------------------------------------------------------------
      // CANVAS DIMENSIONS
      // -----------------------------------------------------------------------

      /** Current canvas width in CSS pixels (not device pixels) */
      let width = 0;
      /** Current canvas height in CSS pixels (not device pixels) */
      let height = 0;

      // -----------------------------------------------------------------------
      // NODE CONFIGURATION
      // -----------------------------------------------------------------------

      /** Array of node objects, each with position (x,y), velocity (vx,vy), and radius */
      const nodes: any[] = [];

      /** Number of nodes in the graph - kept small for performance */
      const numNodes = 25;

      /**
       * Maximum distance (in pixels) between two nodes for a line to be drawn.
       * Larger values = more connections but more rendering work.
       */
      const connectionDistance = 100;

      // -----------------------------------------------------------------------
      // HELPER FUNCTIONS
      // -----------------------------------------------------------------------

      /**
       * Resize the canvas to match its container.
       *
       * IMPORTANT: This function accounts for devicePixelRatio to ensure
       * crisp rendering on high-DPI displays (Retina, etc.). The canvas
       * is scaled up by the pixel ratio, then the context is scaled to
       * compensate, so we can draw in CSS pixel coordinates.
       */
      function resize() {
        const container = canvas.parentElement;
        if (container) {
          width = container.clientWidth;
          height = container.clientHeight;
          // Scale canvas for high-DPI displays
          canvas.width = width * window.devicePixelRatio;
          canvas.height = height * window.devicePixelRatio;
          ctx?.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
      }

      /**
       * Initialize or reset all nodes with random positions and velocities.
       * Called once during setup.
       */
      function initNodes() {
        nodes.length = 0; // Clear existing nodes
        for (let i = 0; i < numNodes; i++) {
          nodes.push({
            x: Math.random() * width, // Random X position
            y: Math.random() * height, // Random Y position
            vx: (Math.random() - 0.5) * 0.5, // Random X velocity (-0.25 to 0.25)
            vy: (Math.random() - 0.5) * 0.5, // Random Y velocity (-0.25 to 0.25)
            radius: Math.random() * 2 + 1, // Random radius (1px to 3px)
          });
        }
      }

      /**
       * Update node positions based on their velocities.
       * Handles edge bouncing to keep nodes within the canvas bounds.
       */
      function update() {
        const padding = 10; // Keep nodes away from edges for visual cleanliness
        nodes.forEach((node) => {
          // Move node by its velocity
          node.x += node.vx;
          node.y += node.vy;

          // Bounce off edges with padding
          if (node.x < padding || node.x > width - padding) node.vx *= -1;
          if (node.y < padding || node.y > height - padding) node.vy *= -1;

          // Clamp position to stay within bounds (safety net)
          node.x = Math.max(padding, Math.min(width - padding, node.x));
          node.y = Math.max(padding, Math.min(height - padding, node.y));
        });
      }

      // -----------------------------------------------------------------------
      // MAIN RENDER LOOP
      // -----------------------------------------------------------------------

      /**
       * Main render function - clears the canvas and draws all nodes and links.
       *
       * CRITICAL: This function checks isAnimating FIRST. If false, it returns
       * immediately without scheduling another frame. This is how the animation
       * pauses when the canvas is off-screen.
       *
       * The check happens at the START of the function (not end) to ensure
       * we don't do any unnecessary work when paused.
       */
      function draw() {
        // PERFORMANCE GATE: Exit early if animation is paused
        // This prevents wasted CPU cycles when canvas is off-screen
        if (!isAnimating || !ctx) return;

        // Clear the canvas for fresh frame
        ctx.clearRect(0, 0, width, height);

        // --- DRAW CONNECTIONS (LINKS) ---
        // Draw lines between nodes that are close enough to be "connected"
        ctx.strokeStyle = "rgba(148, 163, 184, 0.15)"; // Light gray, mostly transparent
        ctx.lineWidth = 0.5;
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            // Calculate distance between nodes
            const dx = nodes[i].x - nodes[j].x;
            const dy = nodes[i].y - nodes[j].y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Only draw if within connection distance
            if (dist < connectionDistance) {
              ctx.beginPath();
              ctx.moveTo(nodes[i].x, nodes[i].y);
              ctx.lineTo(nodes[j].x, nodes[j].y);
              ctx.stroke();
            }
          }
        }

        // --- DRAW NODES ---
        ctx.fillStyle = "#6366f1"; // Indigo color matching brand
        nodes.forEach((node) => {
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
          ctx.fill();
        });

        // Update positions for next frame
        update();

        // Schedule next frame ONLY if still animating
        // This check prevents orphaned animation loops
        if (isAnimating) {
          requestAnimationFrame(draw);
        }
      }

      // -----------------------------------------------------------------------
      // ANIMATION CONTROL FUNCTIONS
      // -----------------------------------------------------------------------

      /**
       * Start the animation loop.
       * Called when the canvas becomes visible via IntersectionObserver.
       *
       * The guard (if !isAnimating) prevents multiple animation loops
       * from being started if this is called repeatedly.
       */
      function startAnimation() {
        if (!isAnimating) {
          isAnimating = true;
          draw(); // Kick off the animation loop
        }
      }

      /**
       * Stop the animation loop.
       * Called when the canvas is no longer visible via IntersectionObserver.
       *
       * Setting isAnimating = false causes the current animation loop to
       * stop on its next iteration (when draw() sees the flag is false).
       * This is a "graceful" stop - no abrupt termination.
       */
      function stopAnimation() {
        isAnimating = false;
      }

      // -----------------------------------------------------------------------
      // INITIALIZATION (with cleanup to prevent listener stacking)
      // -----------------------------------------------------------------------

      // Remove previous resize listener if it exists (prevents stacking)
      if (cleanup.resizeListener) {
        window.removeEventListener("resize", cleanup.resizeListener);
      }

      // Store and add the new resize listener
      cleanup.resizeListener = resize;
      window.addEventListener("resize", resize);

      // Initial setup
      resize();
      initNodes();

      // NOTE: We do NOT call draw() here. Animation starts when
      // IntersectionObserver detects the canvas is visible.

      // -----------------------------------------------------------------------
      // INTERSECTION OBSERVER - VISIBILITY-BASED ANIMATION CONTROL
      // (with cleanup to prevent observer stacking)
      // -----------------------------------------------------------------------

      // Disconnect previous observer if it exists (prevents stacking)
      if (cleanup.graphObserver) {
        cleanup.graphObserver.disconnect();
      }

      /**
       * IntersectionObserver watches for the canvas container's visibility.
       *
       * OPTIONS:
       * - root: null = use the viewport as the root
       * - threshold: 0 = callback fires as soon as ANY part is visible/hidden
       *
       * This is the key performance optimization: we only animate when visible.
       */
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              // Canvas is now visible - start animating
              startAnimation();
            } else {
              // Canvas is now hidden - stop to save resources
              stopAnimation();
            }
          });
        },
        {
          root: null, // Observe relative to viewport
          threshold: 0, // Trigger as soon as any part is visible
        },
      );

      // Store reference for cleanup on next initialization
      cleanup.graphObserver = observer;

      // Start observing the canvas container (or canvas itself if no container)
      const container = canvas.parentElement;
      if (container) {
        observer.observe(container);
      } else {
        observer.observe(canvas);
      }
    }

    // =========================================================================
    // SCROLL-AWARE NAVIGATION LOGIC
    // =========================================================================
    //
    // Shows/hides the navigation bar based on hero section visibility.
    // When hero is visible (top of page): nav is hidden
    // When hero is scrolled past: nav appears
    //
    // Uses IntersectionObserver for efficient scroll detection without
    // continuous scroll event listeners.
    //
    // =========================================================================
    function initNavScrollObserver() {
      const heroSection = document.getElementById("hero-section");
      const navContainer = document.getElementById("nav-container");
      const blurOverlay = document.getElementById("navbar-blur");

      if (heroSection && navContainer) {
        // Disconnect previous observer if it exists (prevents stacking)
        if (cleanup.navObserver) {
          cleanup.navObserver.disconnect();
        }

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (!entry.isIntersecting) {
                // Hero is out of view (scrolled past) -> Show Nav & Blur
                navContainer.classList.remove("nav-hidden");
                navContainer.classList.add("nav-visible");
                blurOverlay?.classList.remove("blur-hidden");
              } else {
                // Hero is in view -> Hide Nav & Blur
                navContainer.classList.remove("nav-visible");
                navContainer.classList.add("nav-hidden");
                blurOverlay?.classList.add("blur-hidden");
              }
            });
          },
          {
            root: null,
            threshold: 0,
            rootMargin: "-100px 0px 0px 0px", // Trigger slightly before hero completely leaves
          },
        );

        // Store reference for cleanup on next initialization
        cleanup.navObserver = observer;

        observer.observe(heroSection);
      }
    }

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    // Run initializers on first load
    initNavScrollObserver();
    initObsidianGraph();

    // =========================================================================
    // VIEW TRANSITIONS HANDLER (with guard to prevent listener stacking)
    // =========================================================================
    //
    // Re-initialize homepage features after View Transitions navigation.
    // The guard ensures only ONE listener is ever attached to the document,
    // preventing duplicate initializations on repeated homepage visits.
    //
    // =========================================================================
    if (!cleanup.pageLoadListener) {
      cleanup.pageLoadListener = () => {
        // Only run on homepage (check for hero section existence)
        if (document.getElementById("hero-section")) {
          initNavScrollObserver();
          initObsidianGraph();
        }
      };
      document.addEventListener("astro:page-load", cleanup.pageLoadListener);
    }
  </script>

  <style>
    /* Homepage Layout */
    .homepage {
      display: flex;
      flex-direction: column;
      gap: 4rem;
      padding: 0; /* Remove padding to allow hero to fill screen */
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Hero Section - Full viewport, centered */
    .hero-section {
      min-height: 100vh;
      min-height: 100dvh; /* Dynamic viewport height for mobile */
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .hero-card {
      padding: 3rem;
      max-width: 600px;
      width: 100%;
      text-align: center;
    }

    .hero-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .hero-profile {
      width: 8rem;
      height: 8rem;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .hero-profile-img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .hero-name {
      font-family: var(--font-heading, "Playfair Display", Georgia, serif);
      font-size: 3rem;
      font-weight: 400;
      line-height: 1.1;
      letter-spacing: -0.07em;
    }

    .hero-glow {
      box-shadow:
        0 0 60px rgba(236, 72, 153, 0.08),
        0 0 120px rgba(236, 72, 153, 0.08),
        0 4px 30px rgba(0, 0, 0, 0.1);
    }

    /* Pulsing dot for Now card */
    .pulse-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      background: #22c55e;
      border-radius: 50%;
      margin-left: 0.5rem;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.5;
        transform: scale(1.2);
      }
    }

    @media (min-width: 768px) {
      .hero-name {
        font-size: 4rem;
      }
    }

    .hero-tagline {
      font-size: 1.125rem;
      color: var(--color-base-content, inherit);
      opacity: 0.8;
      max-width: 400px;
      line-height: 1.6;
    }

    .hero-cards-section {
      margin-top: 1rem;
    }

    .hero-cards-hint {
      text-align: center;
      font-size: 0.875rem;
      color: var(--color-base-content, inherit);
      opacity: 0.6;
      margin-top: 1rem;
    }

    /* ============================================
     * Bento Grid Section
     * Asymmetric grid wrapped in a container card
     * Layout: Writing (wide at top), Photo (tall right),
     *         Now + Uses (stacked on left bottom)
     * ============================================ */
    .bento-section {
      padding: 0 2rem 6rem;
      display: flex;
      justify-content: center;
      width: 100%;
      box-sizing: border-box;
    }

    @media (max-width: 1023px) {
      .bento-section {
        padding: 0 1rem 4rem;
      }
    }

    /* Wrapper card - uses the same glassmorphism as hero */
    .bento-wrapper {
      padding: 3rem 0rem 2rem; /* Minimal side padding */
      max-width: 1400px;
      width: 100%;
      box-sizing: border-box;
    }

    @media (max-width: 1023px) {
      .bento-wrapper {
        padding: 2.5rem 0rem 1.5rem;
      }
    }

    /* Section header inside wrapper */
    .bento-header {
      margin-bottom: 3rem; /* Reduced to bring cards closer */
      padding-top: 2rem;
      text-align: center;
    }

    .bento-header-label {
      font-size: 1rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: var(--color-accent-500, #ec4899);
      display: block;
      margin-bottom: 0.75rem;
    }

    .bento-header-title {
      font-family: var(--font-heading, "Playfair Display", Georgia, serif);
      font-size: 3.5rem;
      font-weight: 400;
      letter-spacing: -0.04em;
      line-height: 1.1;
      color: var(--color-base-content, inherit);
    }

    /* Grid layout - 6 columns for flexible splits */
    .bento-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: clamp(0.75rem, 2vw, 2rem);
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
      align-items: stretch; /* Cards in same row match height (mymind style) */
    }

    /* Row 1: Talks (67%) | Writing (33%) */
    .bento-talks {
      grid-column: span 4;
    }
    .bento-blog {
      grid-column: span 2;
    }

    /* Row 2: Notes (50%) | Now (50%) */
    .bento-notes {
      grid-column: span 3;
    }
    .bento-now {
      grid-column: span 3;
    }

    /* Row 3: Photography (full width) */
    .bento-photography {
      grid-column: span 6;
    }

    /* Row 4: Uses (33%) | Homelab (67%) */
    .bento-uses {
      grid-column: span 2;
    }
    .bento-homelab {
      grid-column: span 4;
    }

    /* Row 5: About (50%) | Contact (50%) */
    .bento-about {
      grid-column: span 3;
    }
    .bento-contact {
      grid-column: span 3;
    }

    /* Mobile: Switch to 1-column linear layout */
    @media (max-width: 640px) {
      .bento-grid {
        grid-template-columns: 1fr;
        gap: 1.25rem;
      }

      /* All cards become full width on mobile */
      .bento-talks,
      .bento-blog,
      .bento-notes,
      .bento-now,
      .bento-photography,
      .bento-uses,
      .bento-homelab,
      .bento-about,
      .bento-contact {
        grid-column: span 1;
      }
    }

    /* Base card styles */
    .bento-card {
      position: relative;
      border-radius: clamp(1.5rem, 3vw, 2.5rem); /* Fluid border radius */
      display: flex;
      flex-direction: column;
      text-decoration: none;
      overflow: hidden;
      transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
      border: 1px solid rgba(255, 255, 255, 0.05);
      min-width: 0; /* Allow grid to control sizing */
    }

    .bento-card:hover {
      transform: translateY(-8px);
      box-shadow: 0 30px 60px -12px rgba(0, 0, 0, 0.3);
      border-color: rgba(255, 255, 255, 0.15);
    }

    /* Visual container at top - grows to fill available space */
    .bento-visual-container {
      width: 100%;
      flex: 1 1 auto; /* Grow to fill remaining card space */
      padding: clamp(0.75rem, 1.5vw, 1.5rem) clamp(0.75rem, 1.5vw, 1.5rem) 0;
      position: relative;
      aspect-ratio: 4/3;
    }

    .bento-image-wrapper {
      width: 100%;
      height: 100%;
      border-radius: 1.5rem;
      overflow: hidden;
      position: relative;
      background: inherit; /* Match card background for seamless letterboxing */
      box-shadow:
        0 10px 30px -10px rgba(0, 0, 0, 0.15),
        0 4px 10px -2px rgba(0, 0, 0, 0.05);

      /* progressive bottom blur mask */
      -webkit-mask-image: linear-gradient(
        to bottom,
        black 85%,
        transparent 100%
      );
      mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
    }

    .bento-image-wrapper img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
    }

    .bento-card:hover .bento-image-wrapper img {
      transform: scale(1.05);
    }

    /* Remove floating effect for Obsidian Graph to keep it filling */
    .bento-notes .bento-visual-container {
      padding: 0;
      height: 240px;
    }

    /* Obsidian Graph Special Container */
    .obsidian-graph-container {
      width: 100%;
      height: 100%;
      background: #0f172a; /* Obsidian dark background */
      position: relative;
    }

    #graph-canvas {
      width: 100%;
      height: 100%;
    }

    .graph-overlay {
      position: absolute;
      top: 1rem;
      right: 1.25rem;
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(4px);
      padding: 0.4rem 0.8rem;
      border-radius: 2rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .graph-text {
      font-size: 0.75rem;
      color: #94a3b8;
      font-weight: 500;
      white-space: nowrap;
    }

    /* Content Container - only takes the space it needs */
    .bento-content-container {
      padding: clamp(1rem, 2vw, 1.5rem) clamp(1.25rem, 2.5vw, 2rem)
        clamp(1.5rem, 3vw, 2.5rem);
      flex: 0 0 auto; /* Don't grow, only take needed space */
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      gap: clamp(0.5rem, 1vw, 0.75rem);
    }

    .bento-meta {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.25rem;
    }

    .bento-category {
      font-size: clamp(0.65rem, 1vw, 0.75rem);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--color-accent, #ec4899);
    }

    .bento-title-aside {
      font-family: var(--font-heading, "Playfair Display", Georgia, serif);
      font-size: 1.1rem;
      font-weight: 500;
      color: var(--color-base-content, inherit);
      opacity: 0.9;
    }

    .bento-card-title {
      font-family: var(--font-heading, "Playfair Display", Georgia, serif);
      font-size: clamp(1.25rem, 2.5vw, 1.85rem); /* Fluid title size */
      font-weight: 500;
      line-height: 1.2;
      color: var(--bento-text, var(--color-base-content, inherit));
      margin: 0;
    }

    .bento-excerpt {
      font-size: clamp(0.875rem, 1.2vw, 1.05rem);
      line-height: 1.6;
      opacity: 0.8;
      color: var(--bento-text, var(--color-base-content, inherit));
      /* Truncate with ellipsis after 3 lines */
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    /* Icon positioned in top right */
    .bento-icon-floating {
      position: absolute;
      top: 1.5rem;
      right: 1.5rem;
      opacity: 0;
      transform: translateX(10px);
      transition: all 0.3s ease;
      color: var(--color-accent, #ec4899);
      z-index: 10;
    }

    .bento-card:hover .bento-icon-floating {
      opacity: 1;
      transform: translateX(0);
    }
    /* Individual Card Styles - Soft Pastels (Light Mode) */
    /* Row 1: Talks/Writing - use aspect-ratio to control height */
    /* Adjust ratio: 3/2 = shorter, 4/3 = taller, 2/1 = very short */
    .bento-talks {
      background: #f0f4f8;
      --bento-text: #2d3436;
      --color-accent: #6b7280;
    }
    .bento-blog {
      background: #fdf2f0;
      --bento-text: #2d3436;
      --color-accent: #6b7280;
    }
    .bento-notes {
      background: #0f172a;
      --bento-text: #ffffff;
      --color-accent: #00d2d3;
    }
    .bento-photography {
      background: #f0f7f4;
      --bento-text: #2d3436;
      --color-accent: #6b7280;
    }
    .bento-now {
      background: #fcf9ee;
      --bento-text: #2d3436;
      --color-accent: #6b7280;
    }
    .bento-uses {
      background: #f6f0f7;
      --bento-text: #2d3436;
      --color-accent: #6b7280;
    }
    .bento-homelab {
      background: #ebf8ff;
      --bento-text: #2d3436;
      --color-accent: #6b7280;
    }
    .bento-about {
      background: #fff5f5;
      --bento-text: #2d3436;
      --color-accent: #6b7280;
    }
    .bento-contact {
      background: #fdf0f7;
      --bento-text: #2d3436;
      --color-accent: #6b7280;
    }

    /* Dark Mode - Muted Pastel Backgrounds */
    :root[data-theme="dark"] .bento-talks {
      background: #1e293b;
      --bento-text: #ffffff;
      --color-accent: #94a3b8;
    }
    :root[data-theme="dark"] .bento-blog {
      background: #2d2327;
      --bento-text: #ffffff;
      --color-accent: #e5b8a8;
    }
    :root[data-theme="dark"] .bento-notes {
      background: #0f172a;
      --bento-text: #ffffff;
      --color-accent: #00d2d3;
    }
    :root[data-theme="dark"] .bento-photography {
      background: #1a2e25;
      --bento-text: #ffffff;
      --color-accent: #6ee7b7;
    }
    :root[data-theme="dark"] .bento-now {
      background: #2a2820;
      --bento-text: #ffffff;
      --color-accent: #fcd34d;
    }
    :root[data-theme="dark"] .bento-uses {
      background: #2a2030;
      --bento-text: #ffffff;
      --color-accent: #c4b5fd;
    }
    :root[data-theme="dark"] .bento-homelab {
      background: #1a2535;
      --bento-text: #ffffff;
      --color-accent: #7dd3fc;
    }
    :root[data-theme="dark"] .bento-about {
      background: #2d2025;
      --bento-text: #ffffff;
      --color-accent: #fca5a5;
    }
    :root[data-theme="dark"] .bento-contact {
      background: #2a2030;
      --bento-text: #ffffff;
      --color-accent: #f9a8d4;
    }

    /* Photography Specific Layout */
    .bento-photography {
      display: flex;
      flex-direction: row-reverse !important; /* Image feature on the right */
      align-items: stretch;
      padding: 0;
      height: clamp(350px, 40vw, 500px); /* Fluid height */
    }

    /* Only switch to column layout on true mobile */
    @media (max-width: 640px) {
      .bento-photography {
        flex-direction: column !important;
        height: auto;
      }
      .bento-photography .bento-visual-container {
        height: clamp(280px, 60vw, 400px);
        flex: none;
      }
    }

    .bento-photography .bento-visual-container {
      flex: 1.2;
      height: 100%;
      padding: 0;
    }

    .bento-photography .bento-content-container {
      flex: 1;
      justify-content: center;
      padding: clamp(1.5rem, 3vw, 3rem);
    }

    .photo-grid-feature {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      overflow: hidden;
    }

    .photo-stack {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 500px;
      aspect-ratio: 1;
    }

    .photo-stack-item {
      position: absolute;
      width: 45%;
      aspect-ratio: 3/4;
      border-radius: 1rem;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
      transition: all 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
      background: white;
    }

    /* Arrangement like the screenshot */
    .photo-stack-item:nth-child(1) {
      top: 10%;
      left: 5%;
      z-index: 2;
      transform: rotate(-5deg);
    }
    .photo-stack-item:nth-child(2) {
      top: 0%;
      left: 45%;
      z-index: 1;
      transform: rotate(2deg);
    }
    .photo-stack-item:nth-child(3) {
      bottom: 5%;
      left: 35%;
      z-index: 3;
      transform: rotate(-2deg);
    }
    .photo-stack-item:nth-child(4) {
      top: 25%;
      right: 0%;
      z-index: 2;
      transform: rotate(5deg);
    }

    .bento-photography:hover .photo-stack-item {
      transform: rotate(0) scale(1.05) translate(0, -10px);
    }

    .photo-stack-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Mobile-specific adjustments */
    @media (max-width: 640px) {
      .bento-section {
        padding: 0 0.75rem 4rem;
      }

      .bento-wrapper {
        padding: 2rem 1rem 1.5rem;
      }

      .bento-header {
        margin-bottom: 3rem;
      }

      .bento-header-title {
        font-size: 2rem;
      }

      /* Visual container gets more height on mobile for better image display */
      .bento-visual-container {
        height: clamp(200px, 50vw, 280px);
      }
    }

    /* Footer Section */
    .footer-section {
      padding: 4rem 0 8rem;
      display: flex;
      justify-content: center;
    }

    .footer-card {
      padding: 3rem;
      max-width: 600px;
      text-align: center;
    }

    .footer-quote {
      font-family: var(--font-heading, "Playfair Display", Georgia, serif);
      font-size: 1.5rem;
      font-style: italic;
      color: var(--color-base-content, inherit);
      opacity: 0.8;
      line-height: 1.4;
      letter-spacing: -0.02em;
    }

    .footer-cta {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 2rem;
      color: var(--color-accent, #ec4899);
      font-size: 1rem;
      text-decoration: none;
      transition: gap 0.3s ease;
    }

    .footer-cta:hover {
      gap: 1rem;
    }

    .footer-cta svg {
      width: 1.25rem;
      height: 1.25rem;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .homepage {
        padding: 0.5rem; /* Go closer to edge */
        gap: 3rem;
      }

      .hero-section {
        flex: 1;
        padding: 1rem 0.5rem; /* Closer to edge */
      }

      .hero-card {
        padding: 2.5rem 1.25rem;
        max-width: 95%; /* Wider on mobile */
      }

      .hero-name {
        font-size: 2.75rem;
      }

      .hero-profile {
        width: 6rem;
        height: 6rem;
      }
    }
  </style>
</BaseLayout>
